#!/usr/bin/perl
# Run perldoc on this file for documentation.

# For the benefit of HTML viewers:
# <div id='cover' style='position: absolute; left: 0; top: 0; width: 10000px; height: 10000px; background: white'></div>

$|++;

my %data;
my %transient;
my %externalized_functions;
my %datatypes;

my %locations;          # Maps eval-numbers to attribute names

sub meta::define_form {
  my ($namespace, $delegate) = @_;
  $datatypes{$namespace} = $delegate;
  *{"meta::${namespace}::implementation"} = $delegate;
  *{"meta::$namespace"} = sub {
    my ($name, $value, %options) = @_;
    chomp $value;
    $data{"${namespace}::$name"} = $value unless $options{no_binding};
    $delegate->($name, $value) unless $options{no_delegate}}}

sub meta::eval_in {
  my ($what, $where) = @_;

  # Obtain next eval-number and alias it to the designated location
  @locations{eval('__FILE__') =~ /\(eval (\d+)\)/} = ($where);

  my $result = eval $what;
  $@ =~ s/\(eval \d+\)/$where/ if $@;
  warn $@ if $@;
  $result}

meta::define_form 'meta', sub {
  my ($name, $value) = @_;
  meta::eval_in($value, "meta::$name")};

meta::meta('configure', <<'__');
# A function to configure transients. Transients can be used to store any number of
# different things, but one of the more common usages is type descriptors.

sub meta::configure {
  my ($datatype, %options) = @_;
  $transient{$_}{$datatype} = $options{$_} for keys %options;
}
__
meta::meta('externalize', <<'__');
# Function externalization. Data types should call this method when defining a function
# that has an external interface.

sub meta::externalize {
  my ($name, $attribute, $implementation) = @_;
  $externalized_functions{$name} = $attribute;
  *{"::$name"} = $implementation || $attribute;
}
__
meta::meta('functor::editable', <<'__');
# An editable type. This creates a type whose default action is to open an editor
# on whichever value is mentioned. This can be changed using different flags.

sub meta::functor::editable {
  my ($typename, %options) = @_;

  meta::configure $typename, %options;
  meta::define_form $typename, sub {
    my ($name, $value) = @_;

    $options{on_bind} && &{$options{on_bind}}($name, $value);

    meta::externalize $options{prefix} . $name, "${typename}::$name", sub {
      my $attribute             = "${typename}::$name";
      my ($command, @new_value) = @_;

      return &{$options{default}}(retrieve($attribute)) if ref $options{default} eq 'CODE' and not defined $command;
      return edit($attribute) if $command eq 'edit' or $options{default} eq 'edit' and not defined $command;
      return associate($attribute, @new_value ? join(' ', @new_value) : join('', <STDIN>)) if $command eq '=' or $command eq 'import' or $options{default} eq 'import' and not defined $command;
      return retrieve($attribute)}}}
__
meta::meta('type::alias', <<'__');
meta::configure 'alias', inherit => 0;
meta::define_form 'alias', sub {
  my ($name, $value) = @_;
  meta::externalize $name, "alias::$name", sub {
    # Can't pre-tokenize because shell::tokenize doesn't exist until the library::
    # namespace has been evaluated (which will be after alias::).
    shell::run(shell::tokenize($value), shell::tokenize(@_));
  };
};
__
meta::meta('type::bootstrap', <<'__');
# Bootstrap attributes don't get executed. The reason for this is that because
# they are serialized directly into the header of the file (and later duplicated
# as regular data attributes), they will have already been executed when the
# file is loaded.

meta::configure 'bootstrap', extension => '.pl', inherit => 1;
meta::define_form 'bootstrap', sub {};
__
meta::meta('type::cache', <<'__');
meta::configure 'cache', inherit => 0;
meta::define_form 'cache', \&meta::bootstrap::implementation;
__
meta::meta('type::cached_dependency', <<'__');
meta::configure 'cached_dependency', inherit => 0, extension => '';
meta::define_form 'cached_dependency', \&meta::bootstrap::implementation;
__
meta::meta('type::configuration', <<'__');
meta::functor::editable 'configuration', inherit => 0, extension => '.conf', default => sub {
  # Any lines starting with #, with or without leading whitespace, are treated as comments.
  # Comments are not parsed in option text; that is, you could specify an option that contained
  # a # and the # and following text would be considered part of that option.
  my ($data) = @_;
  my @options = grep /:/o && ! /^\h*#/o && ! /^\h*$/o, split(/\v+/o, $data);
  s/^\h+//o for @options;
  my @key_values = map split(/\s*:\s*/o, $_, 2), @options;
  $key_values[$_ << 1] and $key_values[$_ << 1] =~ s/\s/_/go for 0 .. @key_values >> 1;
  $key_values[$_ << 1] and $key_values[$_ << 1] = lc $key_values[$_ << 1] for 0 .. @key_values >> 1;
  @key_values;
};
__
meta::meta('type::data', 'meta::functor::editable \'data\', extension => \'\', inherit => 0, default => \'cat\';');
meta::meta('type::function', <<'__');
meta::configure 'function', extension => '.pl', inherit => 1;
meta::define_form 'function', sub {
  my ($name, $value) = @_;
  meta::externalize $name, "function::$name", meta::eval_in("sub {\n$value\n}", "function::$name");
};
__
meta::meta('type::hook', <<'__');
meta::configure 'hook', extension => '.pl', inherit => 0;
meta::define_form 'hook', sub {
  my ($name, $value) = @_;
  *{"hook::$name"} = meta::eval_in("sub {\n$value\n}", "hook::$name");
};
__
meta::meta('type::inc', <<'__');
meta::configure 'inc', inherit => 1, extension => '.pl';
meta::define_form 'inc', sub {
  use File::Path 'mkpath';
  use File::Basename qw/basename dirname/;

  my ($name, $value) = @_;
  my $tmpdir   = basename($0) . '-' . $$;
  my $filename = "/tmp/$tmpdir/$name";

  push @INC, "/tmp/$tmpdir" unless grep /^\/tmp\/$tmpdir$/, @INC;

  mkpath(dirname($filename));
  unless (-e $filename) {
    open my $fh, '>', $filename;
    print $fh $value;
    close $fh;
  }
};
__
meta::meta('type::internal_function', <<'__');
meta::configure 'internal_function', extension => '.pl', inherit => 1;
meta::define_form 'internal_function', sub {
  my ($name, $value) = @_;
  *{$name} = meta::eval_in("sub {\n$value\n}", "internal_function::$name");
};
__
meta::meta('type::js', 'meta::functor::editable \'js\', extension => \'.js\', inherit => 1;');
meta::meta('type::library', <<'__');
meta::configure 'library', extension => '.pl', inherit => 1;
meta::define_form 'library', sub {
  my ($name, $value) = @_;
  meta::eval_in($value, "library::$name");
};
__
meta::meta('type::message_color', <<'__');
meta::configure 'message_color', extension => '', inherit => 1;
meta::define_form 'message_color', sub {
  my ($name, $value) = @_;
  terminal::color($name, $value);
};
__
meta::meta('type::meta', <<'__');
# This doesn't define a new type. It customizes the existing 'meta' type
# defined in bootstrap::initialization. Note that horrible things will
# happen if you redefine it using the editable functor.

meta::configure 'meta', extension => '.pl', inherit => 1;
__
meta::meta('type::note', 'meta::functor::editable \'note\', extension => \'.sdoc\', inherit => 0, default => \'edit\';');
meta::meta('type::parent', <<'__');
meta::define_form 'parent', \&meta::bootstrap::implementation;
meta::configure 'parent', extension => '', inherit => 1;
__
meta::meta('type::retriever', <<'__');
meta::configure 'retriever', extension => '.pl', inherit => 1;
meta::define_form 'retriever', sub {
  my ($name, $value) = @_;
  $transient{retrievers}{$name} = meta::eval_in("sub {\n$value\n}", "retriever::$name");
};
__
meta::meta('type::sdoc', <<'__');
# A meta-type for other types. So retrieve('js::main') will work if you have
# the attribute 'sdoc::js::main'. The filename will be main.js.sdoc.

meta::functor::editable 'sdoc', inherit => 1, extension => sub {
  extension_for(attribute($_[0])) . '.sdoc';
};
__
meta::meta('type::state', <<'__');
# Allows temporary or long-term storage of states. Nothing particularly insightful
# is done about compression, so storing alternative states will cause a large
# increase in size. Also, states don't contain other states -- otherwise the size
# increase would be exponential.

# States are created with the save-state function.

meta::configure 'state', inherit => 0, extension => '.pl';
meta::define_form 'state', \&meta::bootstrap::implementation;
__
meta::meta('type::template', <<'__');
meta::configure 'template', extension => '.pl', inherit => 1;
meta::define_form 'template', sub {
  my ($name, $value) = @_;
  meta::externalize "template::$name", "template::$name", meta::eval_in("sub {\n$value\n}", "template::$name");
};
__
meta::meta('type::watch', 'meta::functor::editable \'watch\', prefix => \'watch::\', inherit => 1, extension => \'.pl\', default => \'cat\';');
meta::alias('e', 'edit sdoc::js::modus');
meta::alias('ec', 'edit sdoc::js::modus.core');
meta::alias('ehist', 'edit sdoc::js::modus.history');
meta::alias('ems', 'edit sdoc::js::modus.mss');
meta::alias('epage', 'edit sdoc::js::modus.page');
meta::bootstrap('html', <<'__');
<html>
  <head>
  <meta http-equiv='content-type' content='text/html; charset=UTF-8' />
  <link rel='stylesheet' href='http://spencertipping.com/perl-objects/web/style.css'/>

  <script src='http://ajax.googleapis.com/ajax/libs/jquery/1.5.2/jquery.min.js'></script>
  <script src='http://spencertipping.com/caterwaul/caterwaul.all.min.js'></script>
  <script src='http://spencertipping.com/montenegro/montenegro.client.js'></script>
  <script src='http://spencertipping.com/perl-objects/web/attribute-parser.js'></script>
  <script src='http://spencertipping.com/perl-objects/web/interface.js'></script>
  </head>
  <body></body>
</html>

__
meta::bootstrap('initialization', <<'__');
#!/usr/bin/perl
# Run perldoc on this file for documentation.

# For the benefit of HTML viewers:
# <div id='cover' style='position: absolute; left: 0; top: 0; width: 10000px; height: 10000px; background: white'></div>

$|++;

my %data;
my %transient;
my %externalized_functions;
my %datatypes;

my %locations;          # Maps eval-numbers to attribute names

sub meta::define_form {
  my ($namespace, $delegate) = @_;
  $datatypes{$namespace} = $delegate;
  *{"meta::${namespace}::implementation"} = $delegate;
  *{"meta::$namespace"} = sub {
    my ($name, $value, %options) = @_;
    chomp $value;
    $data{"${namespace}::$name"} = $value unless $options{no_binding};
    $delegate->($name, $value) unless $options{no_delegate}}}

sub meta::eval_in {
  my ($what, $where) = @_;

  # Obtain next eval-number and alias it to the designated location
  @locations{eval('__FILE__') =~ /\(eval (\d+)\)/} = ($where);

  my $result = eval $what;
  $@ =~ s/\(eval \d+\)/$where/ if $@;
  warn $@ if $@;
  $result}

meta::define_form 'meta', sub {
  my ($name, $value) = @_;
  meta::eval_in($value, "meta::$name")};

__
meta::bootstrap('perldoc', <<'__');
=head1 Self-modifying Perl script

=head2 Original implementation by Spencer Tipping L<http://spencertipping.com>

The prototype for this script is licensed under the terms of the MIT source code license.
However, this script in particular may be under different licensing terms. To find out how
this script is licensed, please contact whoever sent it to you. Alternatively, you may
run it with the 'license' argument if they have specified a license that way.

You should not edit this file directly. For information about how it was constructed, go
to L<http://spencertipping.com/writing-self-modifying-perl>. For quick usage guidelines,
run this script with the 'usage' argument.

=cut

__
meta::cache('parent-identification', <<'__');
/home/spencertipping/bin/configuration aa772900bb5b925cb84346bd72a4249d
/home/spencertipping/bin/node-base da62d84a9e81832f089520c172982c1a
/home/spencertipping/bin/object 99aeabc9ec7fe80b1b39f5e53dc7e49e
/home/spencertipping/bin/repository 05bc3036c343fdb8aec5b0be12a9b19e
/home/spencertipping/conjectures/perl-objects/sdoc a1e8480e579614c01dabeecf0f963bcc
notes a9e5975593ed5d90d943ad98405c71e5
object 99aeabc9ec7fe80b1b39f5e53dc7e49e
preprocessor 70dae4b46eb4e06798ec6f38d17d4c7b
__
meta::cached_dependency('caterwaul.all.js', '(function (f){return f(f)})(function (self,undefined){var qw=function (x){return x.split(/\\s+/)},id=function (x){return x},se=function (x,f){return f&&f.call(x,x)||x},gensym=(function (n,m){return function (){return \'gensym_\'+n.toString(36)+\'_\'+( ++m).toString(36)}})( +new Date(),Math.random()*(1<<30)>>>0),bind=function (f,t){return f.binding===t?f:f.original?bind(f.original,t):merge(function (){return f.apply(t,arguments)},{original:f,binding:t})},map=function (f,xs){for (var i=0,ys=[],l=xs.length;i<l; ++i)ys.push(f(xs[i],i));return ys},hash=function (s){for (var i=0,xs=qw(s),o={},l=xs.length;i<l; ++i)o[xs[i]]=true;return annotate_keys(o)},merge=function (o){for (var i=1,l=arguments.length,_=null;_=arguments[i],i<l; ++i)if (_)for (var k in _)has(_,k)&&(o[k]=_[k]);return o},extend=function (f){merge.apply(null,[f.prototype].concat(Array.prototype.slice.call(arguments,1)));return f},annotate_keys=function (o){var max=0;for (var k in o)own.call(o,k)&&(max=k.length>max?k.length:max);o._max_length=max;return o},has=function (o,p){return p&& !(p.length>o._max_length)&&p!==\'_max_length\'&&own.call(o,p)},own=Object.prototype.hasOwnProperty,_caterwaul=typeof caterwaul===\'undefined\'?undefined:caterwaul,syntax_node_inspect=function (x){return x?x.inspect():\'(<>)\'},syntax_node_tostring=function (x){return x?x.serialize?x.serialize():x.toString():\'\'},node_methods={_replace:function (n){return (n.l=this.l)&&(this.l.r=n),(n.r=this.r)&&(this.r.l=n),this},_append_to:function (n){return n&&n._append(this),this},_reparent:function (n){return this.p&&this.p[0]===this&&(this.p[0]=n),this},_fold_l:function (n){return this._append(this.l&&this.l._unlink(this))},_append:function (n){return (this[this.length++]=n)&&(n.p=this),this},_fold_r:function (n){return this._append(this.r&&this.r._unlink(this))},_sibling:function (n){return n.p=this.p,(this.r=n).l=this},_fold_lr:function (){return this._fold_l()._fold_r()},_wrap:function (n){return n.p=this._replace(n).p,this._reparent(n),delete this.l,delete this.r,this._append_to(n)},_fold_rr:function (){return this._fold_r()._fold_r()},_unlink:function (n){return this.l&&(this.l.r=this.r),this.r&&(this.r.l=this.l),delete this.l,delete this.r,this._reparent(n)},pop:function (){return  --this.length,this},push:function (x){return this[this.length++]=x,this},id:function (){return this.id||(this.id=gensym())},each:function (f){for (var i=0,l=this.length;i<l; ++i)f(this[i],i);return this},map:function (f){for (var n=new this.constructor(this),i=0,l=this.length;i<l; ++i)n.push(f(this[i],i)||this[i]);return n},nmap:function (f){for (var n=new this.constructor(this),i=0,l=this.length,r;i<l; ++i)(r=f(this[i],i))&&n.push(r);return n},reach:function (f){f(this);this.each(function (n){n&&n.reach(f)});return this},rmap:function (f){var r=f(this);return  !r||r===this?this.map(function (n){return n&&n.rmap(f)}):r.data===undefined?new this.constructor(r):r},rnmap:function (f){var r=f(this);return r===this?this.nmap(function (n){return n&&n.rnmap(f)}):r&&r.data===undefined?new this.constructor(r):r},clone:function (){return this.rmap(function (){return false})},collect:function (p){var ns=[];this.reach(function (n){p(n)&&ns.push(n)});return ns},replace:function (rs){return this.rnmap(function (n){return own.call(rs,n.data)?rs[n.data]:n})},repopulated_with:function (xs){return new this.constructor(this.data,xs)},change:function (i,x){return se(new this.constructor(this.data,Array.prototype.slice.call(this)),function (n){n[i]=x})},compose_single:function (i,f){return this.change(i,f(this[i]))},traverse:function (f){f({entering:this});f({exiting:this.each(function (n){n&&n.traverse(f)})});return this},flatten:function (d){d=d||this.data;return d!==this.data?this.as(d): !(has(parse_lr,d)&&this.length)?this:has(parse_associates_right,d)?se(new this.constructor(d),bind(function (n){for (var i=this;i&&i.data===d;i=i[1])n.push(i[0]);n.push(i)},this)):se(new this.constructor(d),bind(function (n){for (var i=this,ns=[];i.data===d;i=i[0])i[1]&&ns.push(i[1]);ns.push(i);for (i=ns.length-1;i>=0; --i)n.push(ns[i])},this))},unflatten:function (){var right=has(parse_associates_right,this.data);return this.length<=2?this:se(new this.constructor(this.data),bind(function (n){if (right)for (var i=0,l=this.length-1;i<l; ++i)n=n.push(this[i]).push(i<l-2?new this.constructor(this.data):this[i])[1];else for (var i=this.length-1;i>=1; --i)n=n.push(i>1?new this.constructor(this.data):this[0]).push(this[i])[0]},this))},as:function (d){return this.data===d?this:new this.constructor(d).push(this)},is_string:function (){return /[\'"]/.test(this.data.charAt(0))},as_escaped_string:function (){return this.data.substr(1,this.data.length-2)},is_number:function (){return /^-?(0x|\\d|\\.\\d+)/.test(this.data)},as_number:function (){return Number(this.data)},is_boolean:function (){return this.data===\'true\'||this.data===\'false\'},as_boolean:function (){return this.data===\'true\'},is_regexp:function (){return /^\\/./.test(this.data)},as_escaped_regexp:function (){return this.data.substring(1,this.data.lastIndexOf(\'/\'))},has_grouped_block:function (){return has(parse_r_until_block,this.data)},is_block:function (){return has(parse_block,this.data)},is_blockless_keyword:function (){return has(parse_r_optional,this.data)},is_null_or_undefined:function (){return this.data===\'null\'||this.data===\'undefined\'},is_constant:function (){return this.is_number()||this.is_string()||this.is_boolean()||this.is_regexp()||this.is_null_or_undefined()},left_is_lvalue:function (){return /=$/.test(this.data)||/\\+\\+$/.test(this.data)||/--$/.test(this.data)},is_empty:function (){return  !this.length},has_parameter_list:function (){return this.data===\'function\'||this.data===\'catch\'},has_lvalue_list:function (){return this.data===\'var\'||this.data===\'const\'},is_dereference:function (){return this.data===\'.\'||this.data===\'[]\'},is_invocation:function (){return this.data===\'()\'},is_contextualized_invocation:function (){return this.is_invocation()&&this[0]&&this[0].is_dereference()},is_invisible:function (){return has(parse_invisible,this.data)},is_binary_operator:function (){return has(parse_lr,this.data)},is_prefix_unary_operator:function (){return has(parse_r,this.data)},is_postfix_unary_operator:function (){return has(parse_l,this.data)},is_unary_operator:function (){return this.is_prefix_unary_operator()||this.is_postfix_unary_operator()},accepts:function (e){return parse_accepts[this.data]&&this.accepts[parse.data]===(e.data||e)},bindings:function (hash){var result=hash||{};this.reach(function (n){if (n.binds_a_value)result[n.data]=n.value});return result},match:function (pattern){return macro_try_match(pattern,this)},ends_with_block:function (){var block_index=parse_r_until_block[this.data],block=this[block_index];return this.data===\'{\'||has(parse_r_until_block,this.data)&&(this.data!==\'function\'||this.length===3)&&block&&block.ends_with_block()},toString:function (){return this.inspect()},inspect:function (){return (this.l?\'(left) <- \':\'\')+\'(\'+this.data+(this.length?\' \'+map(syntax_node_inspect,this).join(\' \'):\'\')+\')\'+(this.r?\' -> \'+this.r.inspect():\'\')},serialize:function (){var op=this.data,right=this.r?\'/* -> \'+this.r.serialize()+\' */\':\'\',space=/\\w/.test(op.charAt(op.length-1))?\' \':\'\',s=has(parse_invisible,op)?map(syntax_node_tostring,this).join(space):has(parse_invocation,op)?map(syntax_node_tostring,[this[0],op.charAt(0),this[1],op.charAt(1)]).join(space):has(parse_ternary,op)?map(syntax_node_tostring,[this[0],op,this[1],parse_group[op],this[2]]).join(space):has(parse_group,op)?op+map(syntax_node_tostring,this).join(space)+parse_group[op]:has(parse_lr,op)?this.length?map(syntax_node_tostring,this).join(space+op+space):op:has(parse_r,op)||has(parse_r_optional,op)?op.replace(/^u/,\' \')+space+(this[0]?this[0].serialize():\'\'):has(parse_r_until_block,op)?has(parse_accepts,op)&&this[1]&&this[2]&&parse_accepts[op]===this[2].data&& !this[1].ends_with_block()?op+space+map(syntax_node_tostring,[this[0],this[1],\';\',this[2]]).join(\'\'):op+space+map(syntax_node_tostring,this).join(\'\'):has(parse_l,op)?(this[0]?this[0].serialize():\'\')+space+op:op;return right?s+right:s}},ref=extend(function (value){if (value instanceof this.constructor){this.value=value.value;this.data=value.data}else {this.value=value;this.data=gensym()}},{length:0,binds_a_value:true},node_methods),syntax_node=extend(function (data){if (data instanceof this.constructor)this.data=data.data,this.length=0;else {this.data=data&&data.toString();this.length=0;for (var i=1,l=arguments.length,_;_=arguments[i],i<l; ++i)for (var j=0,lj=_.length,it,itc;_ instanceof Array?(it=_[j],j<lj):(it=_, !j); ++j)this._append((itc=it.constructor)===String||itc===Number||itc===Boolean?new this.constructor(it):it)}},node_methods),lex_op=hash(\'. new ++ -- u++ u-- u+ u- typeof u~ u! ! * / % + - << >> >>> < > <= >= instanceof in == != === !== & ^ | && || ? = += -= *= /= %= &= |= ^= <<= >>= >>>= : , \'+\'return throw case var const break continue void else u; ;\'),lex_table=function (s){for (var i=0,xs=[false];i<8; ++i)xs.push.apply(xs,xs);for (var i=0,l=s.length;i<l; ++i)xs[s.charCodeAt(i)]=true;return xs},lex_float=lex_table(\'.0123456789\'),lex_decimal=lex_table(\'0123456789\'),lex_integer=lex_table(\'0123456789abcdefABCDEFx\'),lex_exp=lex_table(\'eE\'),lex_space=lex_table(\' \\n\\r\\t\'),lex_bracket=lex_table(\'()[]{}\'),lex_opener=lex_table(\'([{\'),lex_punct=lex_table(\'+-*/%&|^!~=<>?:;.,\'),lex_eol=lex_table(\'\\n\\r\'),lex_regexp_suffix=lex_table(\'gims\'),lex_quote=lex_table(\'\\\'"/\'),lex_slash=\'/\'.charCodeAt(0),lex_star=\'*\'.charCodeAt(0),lex_back=\'\\\\\'.charCodeAt(0),lex_x=\'x\'.charCodeAt(0),lex_dot=\'.\'.charCodeAt(0),lex_zero=\'0\'.charCodeAt(0),lex_postfix_unary=hash(\'++ --\'),lex_ident=lex_table(\'$_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\'),parse_reduce_order=map(hash,[\'function\',\'( [ . [] ()\',\'new delete\',\'u++ u-- ++ -- typeof u~ u! u+ u-\',\'* / %\',\'+ -\',\'<< >> >>>\',\'< > <= >= instanceof in\',\'== != === !==\',\'&\',\'^\',\'|\',\'&&\',\'||\',\'case\',\'?\',\'= += -= *= /= %= &= |= ^= <<= >>= >>>=\',\':\',\',\',\'return throw break continue void\',\'var const\',\'if else try catch finally for switch with while do\',\';\']),parse_associates_right=hash(\'= += -= *= /= %= &= ^= |= <<= >>= >>>= ~ ! new typeof u+ u- -- ++ u-- u++ ? if else function try catch finally for switch case with while do\'),parse_inverse_order=(function (xs){for (var o={},i=0,l=xs.length;i<l; ++i)for (var k in xs[i])has(xs[i],k)&&(o[k]=i);return annotate_keys(o)})(parse_reduce_order),parse_index_forward=(function (rs){for (var xs=[],i=0,l=rs.length,_=null;_=rs[i],xs[i]=true,i<l; ++i)for (var k in _)if (has(_,k)&&(xs[i]=xs[i]&& !has(parse_associates_right,k)))break ;return xs})(parse_reduce_order),parse_lr=hash(\'[] . () * / % + - << >> >>> < > <= >= instanceof in == != === !== & ^ | && || = += -= *= /= %= &= |= ^= <<= >>= >>>= , : ;\'),parse_r_until_block=annotate_keys({\'function\':2,\'if\':1,\'do\':1,\'catch\':1,\'try\':1,\'for\':1,\'while\':1,\'with\':1}),parse_accepts=annotate_keys({\'if\':\'else\',\'do\':\'while\',\'catch\':\'finally\',\'try\':\'catch\'}),parse_invocation=hash(\'[] ()\'),parse_r_optional=hash(\'return throw break continue else\'),parse_also_expression=hash(\'function\'),parse_r=hash(\'u+ u- u! u~ u++ u-- new typeof finally var const void delete\'),parse_block=hash(\'; {\'),parse_invisible=hash(\'i;\'),parse_l=hash(\'++ --\'),parse_group=annotate_keys({\'(\':\')\',\'[\':\']\',\'{\':\'}\',\'?\':\':\'}),parse_ambiguous_group=hash(\'[ (\'),parse_ternary=hash(\'?\'),parse_not_a_value=hash(\'function if for while catch\'),parse=function (input){var s=input.toString(),mark=0,c=0,re=true,esc=false,dot=false,exp=false,close=0,t=\'\',i=0,l=s.length,cs=function (i){return s.charCodeAt(i)},grouping_stack=[],gs_top=null,head=null,parent=null,indexes=map(function (){return []},parse_reduce_order),invocation_nodes=[],all_nodes=[],new_node=function (n){return all_nodes.push(n),n},push=function (n){return head?head._sibling(head=n):(head=n._append_to(parent)),new_node(n)};while ((mark=i)<l){while (lex_space[c=cs(i)]&&i<l)mark= ++i;esc=exp=dot=t=false;if (lex_bracket[c]){t= ! ! ++i;re=lex_opener[c]}else if (c===lex_slash&&cs(i+1)===lex_star&&(i+=2)){while ( ++i<l&&cs(i)!==lex_slash||cs(i-1)!==lex_star);t= ! ++i}else if (c===lex_slash&&cs(i+1)===lex_slash){while ( ++i<l&& !lex_eol[cs(i)]);t=false}else if (lex_quote[c]&&(close=c)&&re&& !(re= !(t=s.charAt(i)))){while ( ++i<l&&(c=cs(i))!==close||esc)esc= !esc&&c===lex_back;while ( ++i<l&&lex_regexp_suffix[cs(i)]);t=true}else if (c===lex_zero&&lex_integer[cs(i+1)]){while ( ++i<l&&lex_integer[cs(i)]);re= !(t=true)}else if (lex_float[c]&&(c!==lex_dot||lex_decimal[cs(i+1)])){while ( ++i<l&&(lex_decimal[c=cs(i)]||(dot^(dot|=c===lex_dot))||(exp^(exp|=lex_exp[c]&& ++i))));while (i<l&&lex_decimal[cs(i)]) ++i;re= !(t=true)}else if (lex_punct[c]&&(t=re?\'u\':\'\',re=true)){while (i<l&&lex_punct[cs(i)]&&has(lex_op,t+s.charAt(i)))t+=s.charAt(i++);re= !has(lex_postfix_unary,t)}else {while ( ++i<l&&lex_ident[cs(i)]);re=has(lex_op,t=s.substring(mark,i))}if (i===mark)throw new Error(\'Caterwaul lex error at "\'+s.substr(mark,40)+\'" with leading context "\'+s.substr(mark-40,40)+\'" (probably a Caterwaul bug)\');if (t===false)continue ;t=t===true?s.substring(mark,i):t===\'u;\'?\';\':t;t===gs_top?(grouping_stack.pop(),gs_top=grouping_stack[grouping_stack.length-1],head=head?head.p:parent,parent=null):(has(parse_group,t)?(grouping_stack.push(gs_top=parse_group[t]),parent=push(new_node(new syntax_node(t))),head=null):push(new_node(new syntax_node(t))),has(parse_inverse_order,t)&&indexes[parse_inverse_order[t]].push(head||parent));re|=t===\')\'&&head.l&&has(parse_r_until_block,head.l.data)}for (var i=0,l=indexes.length,forward,_;_=indexes[i],forward=parse_index_forward[i],i<l; ++i)for (var j=forward?0:_.length-1,lj=_.length,inc=forward?1: -1,node,data;node=_[j],data=node&&node.data,forward?j<lj:j>=0;j+=inc)if (has(parse_lr,data))node._fold_lr();else if (has(parse_ambiguous_group,data)&&node.l&&(node.l.data===\'.\'|| !(has(lex_op,node.l.data)||has(parse_not_a_value,node.l.data))))invocation_nodes.push(node.l._wrap(new_node(new syntax_node(data+parse_group[data]))).p._fold_r());else if (has(parse_l,data))node._fold_l();else if (has(parse_r,data))node._fold_r();else if (has(parse_ternary,data)){node._fold_lr();var temp=node[1];node[1]=node[0];node[0]=temp}else if (has(parse_r_until_block,data)&&node.r&&node.r.data!==\':\'){for (var count=0,limit=parse_r_until_block[data];count<limit&&node.r&& !has(parse_block,node.r.data); ++count)node._fold_r();node.r&&node.r.data!==\';\'&&node._fold_r();if (has(parse_accepts,data)&&parse_accepts[data]===(node.r&&node.r.r&&node.r.r.data))node._fold_r().pop()._fold_r();else if (has(parse_accepts,data)&&parse_accepts[data]===(node.r&&node.r.data))node._fold_r()}else if (has(parse_r_optional,data))node.r&&node.r.data!==\';\'&&node._fold_r();for (var i=all_nodes.length-1,_;_=all_nodes[i],i>=0; --i)_.r&&_._wrap(new syntax_node(\'i;\')).p._fold_r();for (var i=0,l=invocation_nodes.length,_,child;_=invocation_nodes[i],i<l; ++i)(child=_[1]=_[1][0])&&(child.p=_);while (head.p)head=head.p;for (var i=all_nodes.length-1;i>=0; --i)delete all_nodes[i].p;return head},macro_array_push=Array.prototype.push,macro_try_match=function (pattern,t){if (pattern.data===\'_\')return [t];if (pattern.data!==t.data||pattern.length!==t.length)return null;for (var i=0,l=pattern.length,wildcards=[],match=null;i<l; ++i)if (match=macro_try_match(pattern[i],t[i]))macro_array_push.apply(wildcards,match);else return null;return wildcards},macro_expand=function (t,macros,expanders,context){return t.rmap(function (n){for (var i=macros.length-1,macro,match,replacement;i>=0&&(macro=macros[i]); --i)if ((match=macro_try_match(macro,n))&&(replacement=expanders[i].apply(context,match)))return replacement})},compile=function (tree,environment){var vars=[],values=[],bindings=merge({},environment||{},tree.bindings()),s=gensym();for (var k in bindings)if (has(bindings,k))vars.push(k),values.push(bindings[k]);var code=map(function (v){return v===\'this\'?\'\':\'var \'+v+\'=\'+s+\'.\'+v},vars).join(\';\')+\';return(\'+tree.serialize()+\')\';try {return (new Function(s,code)).call(bindings[\'this\'],bindings)}catch (e){throw new Error(\'Caught \'+e+\' while compiling \'+code)}},associator_for=function (f){return function (name,behavior,value){return f[name]=(f.behaviors[f.attributes[name]=behavior]||id).call(f,value),f}},shallow_copy=function (x){return x&&(x.constructor===Array?x.slice():x.clone?x.clone():merge({},x))},copy_of=function (f){var g=merge(function (){return g.init.apply(g,arguments)},{behaviors:shallow_copy(f.behaviors),attributes:{}});return se(g,function (g){(g.associate=associator_for(g))(\'behavior\',\'method\',function (name,definition){this.behaviors[name]=definition;return this.associate(name,\'method\',function (attribute,value){return this.associate(attribute,name,value)})}).behavior(\'method\',g.behaviors.method);for (var k in f.attributes)has(f.attributes,k)&&g.associate(k,f.attributes[k],f[k])})},replica=se(function (){return copy_of({behaviors:{method:function (v){return bind(v,this)}}}).behavior(\'field\').behavior(\'shallow\',shallow_copy)},function (f){f.init=f}),configurable=function (f){return f.shallow(\'configurations\',{}).shallow(\'has\',{}).method(\'configuration\',function (name,f){this.configurations[name]=f;return this}).method(\'namespace\',function (s){return this[s]||this.shallow(s,{})[s]}).method(\'clone\',function (){return arguments.length?this.clone().configure.apply(null,arguments):copy_of(this)}).method(\'configure\',function (){for (var i=0,l=arguments.length,_;_=arguments[i],i<l; ++i)if (_.constructor===String)for (var cs=qw(arguments[i]),j=0,lj=cs.length;_=cs[j],j<lj; ++j)if (this.configurations[_])this.has[_]||(this.has[_]=this.configurations[_].call(this,this)||this);else throw new Error(\'error: configuration "\'+_+\'" does not exist\');else _ instanceof Array?this.configure.apply(this,_.slice()):_.call(this,this);return this})},macroexpansion=function (f){return f.shallow(\'macro_patterns\',[]).method(\'macro\',function (pattern,expansion){return this.macro_patterns.push(pattern),this.macro_expanders.push(expansion),this}).shallow(\'macro_expanders\',[]).method(\'macroexpand\',function (t){return macro_expand(t,this.macro_patterns,this.macro_expanders,this)}).method(\'rmacro\',function (pattern,expander){if ( !expander.apply)throw new Error(\'rmacro: Cannot define macro with non-function expander\');else return this.macro(pattern,function (){var t=expander.apply(this,arguments);return t&&this.macroexpand(t)})})},composition=function (f){return f.shallow(\'after_functions\',[]).method(\'after\',function (){if (arguments.length){for (var i=0,l=arguments.length;i<l; ++i)this.after_functions.push(arguments[i]);return this}else return this.after_functions})},caterwaul_core=function (f){return configurable(f).configure(macroexpansion,composition).method(\'tconfiguration\',function (configs,name,f,bindings){this.configurations[name]=this.clone(configs)(f,bindings);return this}).field(\'syntax\',syntax_node).field(\'ref\',ref).field(\'parse\',parse).field(\'compile\',compile).field(\'gensym\',gensym).field(\'map\',map).field(\'self\',self).field(\'macroexpansion\',macroexpansion).field(\'replica\',replica).field(\'configurable\',configurable).field(\'caterwaul\',caterwaul_core).field(\'decompile\',parse).field(\'composition\',composition).field(\'global\',function (){return caterwaul_global}).method(\'init\',function (f,environment){var result=f.constructor===this.syntax?this.macroexpand(f):this.compile(this(this.decompile(f)),environment);if (f.constructor===this.syntax)for (var i=0,l=this.after_functions.length;i<l; ++i)result=this.after_functions[i](result);return result}).method(\'reinitialize\',function (transform,erase_configurations){var c=transform(this.self),result=c(c).deglobalize();erase_configurations||(result.configurations=this.configurations);return result}).shallow(\'util\',{extend:extend,merge:merge,se:se,macro_try_match:macro_try_match,id:id,bind:bind,map:map,qw:qw}).method(\'magic\',(function (table){return function (name){return table[name]||(table[name]={})}})({}))},caterwaul_global=caterwaul=caterwaul_core(merge(replica(),{deglobalize:function (){caterwaul=_caterwaul;return this}}));return caterwaul_global});caterwaul.configuration(\'std.qs\',function (){this.macro(this.parse(\'qs[_]\'),function (tree){return new this.ref(tree)}).macro(this.parse(\'qse[_]\'),function (tree){return new this.ref(this.macroexpand(tree))}).macro(this.parse(\'literal[_]\'),function (tree){return tree})}).tconfiguration(\'std.qs\',\'std.qg\',function (){this.rmacro(qs[qg[_]],function (expression){return expression.as(\'(\')})}).tconfiguration(\'std.qs std.qg\',\'std.fn\',function (){this.configure(\'std.qg\').rmacro(qs[fn[_][_]],function (vars,expression){return qs[qg[function (vars){return expression}]].replace({vars:vars,expression:expression})}).rmacro(qs[fn_[_]],function (expression){return qs[qg[function (){return expression}]].replace({expression:expression})}).rmacro(qs[fb[_][_]],function (vars,expression){return qse[fn[_t][fn_[fn[vars][e].apply(_t,arguments)]](this)].replace({_t:this.gensym(),vars:vars,e:expression})}).rmacro(qs[fb_[_]],function (expression){return qse[fn[_t][fn_[fn_[e].apply(_t,arguments)]](this)].replace({_t:this.gensym(),e:expression})}).rmacro(qs[fc[_][_]],function (vars,body){return qse[qg[fn[vars][body,undefined]]].replace({vars:vars,body:body})}).rmacro(qs[fc_[_]],function (body){return qse[qg[fn[vars][body,undefined]]].replace({body:body})})}).tconfiguration(\'std.qs std.qg std.fn\',\'std.obj\',function (){this.configure(\'std.qg std.fn\').rmacro(qs[_/mb/_],fn[object,method][qse[qg[fn[_o][_o.m&&fn_[_o.m.apply(_o,arguments)]]](o)].replace({_o:this.gensym(),o:object,m:method})]).rmacro(qs[_/mb[_]],fn[object,method][qse[qg[fn[_o,_m][_o[_m]&&fn_[_o[_m].apply(_o,arguments)]]](o,m)].replace({_o:this.gensym(),_m:this.gensym(),o:object,m:method})]).rmacro(qs[_/se._[_]],fn[v,n,b][qse[qg[fn[n][b,n]].call(this,v)].replace({b:b,n:n,v:v})]).rmacro(qs[_/se[_]],fn[v,b][qse[v/se._[b]].replace({b:b,v:v})]).rmacro(qs[_/re._[_]],fn[v,n,b][qse[qg[fn[n][b]].call(this,v)].replace({b:b,n:n,v:v})]).rmacro(qs[_/re[_]],fn[v,b][qse[v/re._[b]].replace({b:b,v:v})])}).tconfiguration(\'std.qs std.qg std.fn\',\'std.bind\',function (){this.configure(\'std.qg\');var lf=fb[form][this.rmacro(form,l_expander)],lsf=fb[form][this.rmacro(form,l_star_expander)],l_star_expander=fb[vars,expression][qs[qg[function (){var vars;return expression}].call(this)].replace({vars:this.macroexpand(vars),expression:expression})],l_expander=fb[vars,expression][vars=this.macroexpand(vars).flatten(\',\'),qs[qg[function (vars){return e}].call(this,values)].replace({vars:vars.map(fn[n][n[0]]).unflatten(),e:expression,values:vars.map(fn[n][n[1]]).unflatten()})];lf(qs[l[_] in _]),lf(qs[l[_][_]]),lf(this.parse(\'let [_] in _\')),lf(this.parse(\'let [_][_]\')).rmacro(qs[_,where[_]],fn[expression,vars][l_expander(vars,expression)]);lsf(qs[l*[_] in _]),lsf(qs[l*[_][_]]),lsf(this.parse(\'let*[_] in _\')),lsf(this.parse(\'let*[_][_]\')).rmacro(qs[_,where*[_]],fn[expression,vars][l_star_expander(vars,expression)])}).tconfiguration(\'std.qs std.qg std.fn\',\'std.lvalue\',function (){this.rmacro(qs[_(_)=_],fn[base,params,value][qs[base=qg[function (params){return value}]].replace({base:base,params:params,value:value})])}).tconfiguration(\'std.qs std.fn\',\'std.cond\',function (){this.configure(\'std.qg\').rmacro(qs[_,when[_]],fn[expression,cond][qs[qg[l]&&qg[r]].replace({l:cond,r:expression})]).rmacro(qs[_,unless[_]],fn[expression,cond][qs[ !qg[l]&&qg[r]].replace({l:cond,r:expression})])}).tconfiguration(\'std.qs std.fn std.bind std.lvalue\',\'std.defmacro\',function (){l[wildcard(n)=n.data.constructor===String&&n.data.charAt(0)===\'_\'&&\'_\'] in this.macro(qs[defmacro[_][_]],fn[pattern,expansion][this.rmacro(pattern,this.compile(this.macroexpand(expansion))),qs[null]]).macro(qs[defsubst[_][_]],fn[pattern,expansion][this.rmacro(pattern.rmap(wildcard),l[wildcards=pattern.collect(wildcard)] in fn_[l[hash={},as=arguments][this.util.map(fn[v,i][hash[v.data]=as[i]],wildcards),expansion.replace(hash)]]),qs[null]])}).tconfiguration(\'std.qs std.fn std.bind\',\'std.with_gensyms\',function (){this.rmacro(qs[with_gensyms[_][_]],fn[vars,expansion][l[bindings={}][vars.flatten(\',\').each(fb[v][bindings[v.data]=this.gensym()]),qs[qs[_]].replace({_:expansion.replace(bindings)})]])}).tconfiguration(\'std.qs std.fn\',\'std.compile_eval\',function (){this.macro(qs[compile_eval[_]],fn[e][new this.ref(this.compile(this.macroexpand(qs[fn_[_]].replace({_:e}))).call(this))])}).tconfiguration(\'std.qs std.fn\',\'std.ref\',function (){this.macro(qs[caterwaul],fn_[new this.ref(this)])}).tconfiguration(\'std.qs std.bind std.lvalue\',\'std.locally\',function (){l*[t=this,handler(c,e)=t.clone(c.is_string()?c.as_escaped_string():c.data).macroexpand(e)] in this.macro(qs[locally[_][_]],handler).macro(qs[locally._[_]],handler)}).tconfiguration(\'std.qs std.fn std.bind\',\'std.string\',function (){this.rmacro(qs[_],fn[string][string.is_string()&&/#\\{[^\\}]+\\}/.test(string.data)&&l*[q=string.data.charAt(0),s=string.as_escaped_string(),eq=new RegExp(\'\\\\\\\\\'+q,\'g\'),strings=s.split(/#\\{[^\\}]+\\}/),xs=[],result=new this.syntax(\'+\')][s.replace(/#\\{([^\\}]+)\\}/g,fn[_,s][xs.push(s),\'\']),this.util.map(fb[x,i][result.push(new this.syntax(q+(i<strings.length?strings[i]:\'\')+q)).push(new this.syntax(\'(\',this.parse(xs[i].replace(eq,q))))],xs),new this.syntax(\'(\',result.push(new this.syntax(q+(xs.length<strings.length?strings[strings.length-1]:\'\')+q)).unflatten())]])}).configuration(\'std\',function (){this.configure(\'std.qs std.qg std.bind std.lvalue std.cond std.fn std.obj std.defmacro std.with_gensyms std.ref std.locally std.compile_eval std.string\')});caterwaul.tconfiguration(\'std\',\'opt.unroll\',function (){this.rmacro(qs[opt.unroll[_,_][_]],fn[variable,iterations,body][with_gensyms[l,rs,es,j][qg[function (l){for (var rs=l>=0&&l>>3,es=l>=0&&l&7,_i_=0;_i_<es; ++_i_)_body_;for (var j=0;j<rs; ++j){_body_;_i_++;_body_;_i_++;_body_;_i_++;_body_;_i_++;_body_;_i_++;_body_;_i_++;_body_;_i_++;_body_;_i_++};return l}].call(this,_iterations_)].replace({_i_:variable,_body_:body,_iterations_:iterations})])});caterwaul.configuration(\'opt\',function (){this.configure(\'opt.unroll\')});caterwaul.configuration(\'continuation.core\',function (){this.shallow(\'continuation\',{})}).tconfiguration(\'std\',\'continuation.unwind\',function (){this.configure(\'std.fn continuation.core\').continuation/se[_.unwind_protect=function (escape,f){try {return f()}catch (e){return escape(e)}},_.unwind=function (e){throw e}];this.rmacro(qs[unwind_protect[_][_]],fn[escape,body][qse[_f(fb[e][_escape],fb_[_body])].replace({_f:new this.ref(this.continuation.unwind_protect),_escape:escape,_body:body})]).rmacro(qs[unwind[_]],fn[e][qs[_f(_e)].replace({_f:new this.ref(this.continuation.unwind),_e:e})])}).tconfiguration(\'std\',\'continuation.cps\',function (){l*[cps_convert(v,f,b,bound)=qse[l[_=_c][_f]].replace({_c:caterwaul.macroexpand(qs[_f[_v][_b]].replace({_f:bound?qs[fb]:qs[fn]})).replace({_v:v.as(\'(\')[0],_b:b}),_f:f}),l_cps_def(t,form,bound)=l[inductive(cs,v,f,b)=qs[l/cps[cs][_f]].replace({cs:cs,_f:cps_convert(v,f,b,bound)}),base(v,f,b)=cps_convert(v,f,b,bound)] in t.rmacro(qs[l/_form[_,_< -_] in _].replace({_form:form}),inductive).rmacro(caterwaul.parse(\'let/#{form.serialize()}[_, _ <- _] in _\'),inductive).rmacro(qs[l/_form[_< -_] in _].replace({_form:form}),base).rmacro(caterwaul.parse(\'let/#{form.serialize()}[   _ <- _] in _\'),base).rmacro(qs[l/_form[_,_< -_][_]].replace({_form:form}),inductive).rmacro(caterwaul.parse(\'let/#{form.serialize()}[_, _ <- _][_]\'),inductive).rmacro(qs[l/_form[_< -_][_]].replace({_form:form}),base).rmacro(caterwaul.parse(\'let/#{form.serialize()}[   _ <- _][_]\'),base),cps_def(t,form,bound)=t.rmacro(qs[_/_form[_]].replace({_form:form}),fn[f,b][qse[_f/_form._[_b]].replace({_form:form,_f:f,_b:b})]).rmacro(qs[_/_form._[_]].replace({_form:form}),fn[f,v,b][qse[l[_=_c][_f]].replace({_c:caterwaul.macroexpand(qs[_f[_v][_b]].replace({_f:bound?qs[fb]:qs[fn]})).replace({_v:v,_b:b}),_f:f})])] in this.configure(\'std.fn continuation.core\')/se[cps_def(_,qs[cps],false),cps_def(_,qs[cpb],true),l_cps_def(_,qs[cps],false),l_cps_def(_,qs[cpb],true)]}).tconfiguration(\'std\',\'continuation.delimited\',function (){l[magic=this.configure(\'continuation.core\').continuation.magic=this.magic(\'continuation.delimited\')] in this.continuation/se[_.call_cc=function (f){var escaped=false,cc=function (x){escaped=true;throw x},frame={magic:magic,continuation:f,parameters:[cc]};try {while ((frame=frame.continuation.apply(this,frame.parameters))&&frame&&frame.magic===magic);return frame}catch (e){if (escaped)return e;else throw e}},_.call_tail()={magic:magic,continuation:this,parameters:arguments}];this.rmacro(qs[call/cc[_]],fn[f][qs[qg[_call_cc.call(this,_f)]].replace({_call_cc:new this.ref(this.continuation.call_cc),_f:f})]).rmacro(qs[call/tail[_(_)]],fn[f,args][qs[qg[_call_tail.call(_f,_args)]].replace({_call_tail:new this.ref(this.continuation.call_tail),_f:f,_args:args})])}).configuration(\'continuation\',function (){this.configure(\'continuation.core continuation.unwind continuation.cps continuation.delimited\')});caterwaul.tconfiguration(\'std\',\'seq.core\',function (){this.shallow(\'seq\',{core:fn_[null]/se[_.prototype=[]/se.p[p.constructor=_]]})}).tconfiguration(\'std opt\',\'seq.finite.core\',function (){this.configure(\'seq.core\').seq.finite=fc[xs][this.length=this.l=xs?opt.unroll[i,xs.size?xs.size():xs.length][this[i]=xs[i]]:0]/se.c[c.prototype=new this.seq.core()/se[_.size()=this.l||this.length,_.slice()=[]/se[opt.unroll[i,this.size()][_.push(this[i])]],_.constructor=c]]}).tconfiguration(\'std\',\'seq.finite.serialization\',function (){this.configure(\'seq.finite.core\').seq.finite.prototype/se[_.toString()=\'seq[#{this.slice().join(", ")}]\',_.join(x)=this.slice().join(x)]}).tconfiguration(\'std opt\',\'seq.finite.mutability\',function (){l[push=Array.prototype.push,slice=Array.prototype.slice] in this.configure(\'seq.finite.core\').seq.finite.prototype/se[_.push()=l[as=arguments] in opt.unroll[i,as.length][this[this.l++]=as[i]]/re[this.length=this.l,this],_.pop()=this[ --this.l]/se[delete this[this.length=this.l]],_.concat(xs)=new this.constructor(this)/se[_.push.apply(_,slice.call(xs))]]}).tconfiguration(\'std\',\'seq.finite.object\',function (){l[own=Object.prototype.hasOwnProperty] in this.configure(\'seq.finite.core\').seq.finite/se[_.keys(o,all)=new _()/se[(function (){for (var k in o)if (all||own.call(o,k))_.push(k)})()],_.values(o,all)=new _()/se[(function (){for (var k in o)if (all||own.call(o,k))_.push(o[k])})()],_.pairs(o,all)=new _()/se[(function (){for (var k in o)if (all||own.call(o,k))_.push([k,o[k]])})()],_.prototype.object(o)=(o||{})/se[this.each(fn[p][_[p[0]]=p[1]])]]}).tconfiguration(\'std opt\',\'seq.finite.traversal\',function (){this.configure(\'seq.finite.core seq.finite.mutability\').seq.finite.prototype/se[_.map(f)=new this.constructor()/se[opt.unroll[i,this.l][_.push(f.call(this,this[i],i))]],_.filter(f)=new this.constructor()/se[opt.unroll[i,this.l][_.push(this[i]),when[f.call(this,this[i],i)]]],_.each(f)=this/se[opt.unroll[i,_.l][f.call(_,_[i],i)]],_.reversed()=new this.constructor()/se[l[l=this.l] in opt.unroll[i,l][_.push(this[l-i-1])]],_.flat_map(f)=new this.constructor()/se[this.each(fn[x,xi][(f.call(this,x,xi)/re.xs[xs.each?xs:new this.constructor(xs)]).each(fn[x][_.push(x)])])],_.foldl(f,x)=l[x=arguments.length>1?x:this[0],xi=2-arguments.length][opt.unroll[i,this.l-xi][x=f.call(this,x,this[i+xi],i+xi)],x,when[this.l>=xi]],_.foldr(f,x)=l[x=arguments.length>1?x:this[this.l-1],xi=3-arguments.length,l=this.l][opt.unroll[i,l-(xi-1)][x=f.call(this,this[l-(i+xi)],x,l-(i+xi))],x,when[l>=xi-1]]]}).tconfiguration(\'std opt\',\'seq.finite.zip\',function (){this.configure(\'seq.finite.traversal\').seq.finite/se[l[seq=_,slice=Array.prototype.slice][_.prototype.zip()=l[as=new seq([this].concat(slice.call(arguments))),options={f:fn_[new seq(arguments)],outer:false}][caterwaul.util.merge(options,as.pop()),when[as[as.size()-1].constructor===Object],l[l=as.map(fn[x][x.size?x.size():x.length]).foldl(options.outer?fn[x,y][Math.max(x,y)]:fn[x,y][Math.min(x,y)]),f=options.f] in new this.constructor()/se[opt.unroll[i,l][_.push(f.apply({i:i},as.map(fn[x][x[i]]).slice()))]]]]]}).tconfiguration(\'std opt continuation\',\'seq.finite.quantification\',function (){this.configure(\'seq.finite.core\').seq.finite.prototype/se[_.exists(f)=call/cc[fb[cc][opt.unroll[i,this.l][f.call(this,this[i],i)/re[_&&cc(_)]],false]],_.forall(f)= !this.exists(fn_[ !f.apply(this,arguments)])]}).tconfiguration(\'std\',\'seq.infinite.core\',function (){this.configure(\'seq.core\').seq.infinite=fn_[null]/se[_.prototype=new this.seq.core()/se[_.constructor=ctor],where[ctor=_]]/se[_.def(name,ctor,h,t)=i[name]=ctor/se[_.prototype=new i()/se[_.h=h,_.t=t,_.constructor=ctor]],where[i=_],_.def(\'cons\',fn[h,t][this._h=h,this._t=t],fn_[this._h],fn_[this._t]),_.def(\'k\',fn[x][this._x=x],fn_[this._x],fn_[this])]}).tconfiguration(\'std\',\'seq.infinite.y\',function (){this.configure(\'seq.infinite.core\').seq.infinite.def(\'y\',fc[f,x][this._f=f,this._x=x],fn_[this._x],fn_[new this.constructor(this._f,this._f(this._x))])}).tconfiguration(\'std continuation\',\'seq.infinite.transform\',function (){this.configure(\'seq.infinite.core\').seq.infinite/se[_.prototype.map(f)=new _.map(f,this),_.def(\'map\',fc[f,xs][this._f=f,this._xs=xs],fn_[this._f(this._xs.h())],fn_[new this.constructor(this._f,this._xs.t())]),_.prototype.filter(f)=new _.filter(f,this),_.def(\'filter\',fc[f,xs][this._f=f,this._xs=l*[next(s)(cc)=f(s.h())?cc(s):call/tail[next(s.t())(cc)]] in call/cc[next(xs)]],fn_[this._xs.h()],fn_[new this.constructor(this._f,this._xs.t())])]}).tconfiguration(\'std continuation\',\'seq.infinite.traversal\',function (){l[finite=this.configure(\'seq.finite.core seq.finite.mutability\').seq.finite] in this.configure(\'seq.infinite.core\').seq.infinite.prototype/se[_.drop(f)=l*[next(s)(cc)=f(s.h())?call/tail[next(s.t())(cc)]:cc(s)] in call/cc[next(this)],_.take(f)=l*[xs=new finite(),next(s)(cc)=l[h=s.h()][f(h)?(xs.push(h),call/tail[next(s.t())(cc)]):cc(xs)]] in call/cc[next(this)]]}).tconfiguration(\'std opt continuation\',\'seq.dsl\',function (){this.configure(\'seq.core seq.infinite.y seq.finite.core seq.finite.zip seq.finite.traversal seq.finite.mutability\').seq.dsl=caterwaul.global().clone()/se[_.prefix_substitute(tree,prefix)=tree.rmap(fn[n][new n.constructor(\'#{prefix}#{n.data.substring(1)}\'),when[n.data.charAt(0)===\'_\']]),_.define_functional(op,expansion,xs)=trees_for(op).map(fn[t,i][_.macro(t,fn[l,v,r][expansion.replace({x:_.macroexpand(l),y:i<4?qs[fn[xs][y]].replace({xs:_.prefix_substitute(xs,i&1?v.data:\'_\'),y:(i&2?_.macroexpand:fn[x][x])(r||v)}):v})])]),_.define_functional/se[_(\'%\',qs[x.filter(y)],qs[_,_i]),_(\'*\',qs[x.map(y)],qs[_,_i]),_(\'/\',qs[x.foldl(y)],qs[_,_0,_i]),_(\'%!\',qs[x.filter(c(y))].replace({c:not}),qs[_,_i]),_(\'*!\',qs[x.each(y)],qs[_,_i]),_(\'/!\',qs[x.foldr(y)],qs[_,_0,_i]),_(\'&\',qs[x.forall(y)],qs[_,_i]),_(\'|\',qs[x.exists(y)],qs[_,_i]),_(\'-\',qs[x.flat_map(y)],qs[_,_i]),_(\'>>\',qs[x.drop(y)],qs[_]),_(\'<<\',qs[x.take(y)],qs[_]),_(\'>>>\',qs[new r(y,x)].replace({r:new this.ref(this.seq.infinite.y)}),qs[_])],seq(qw(\'> < >= <= == !=\')).each(fn[op][_.macro(qs[_+_].clone()/se[_.data=op],rxy(qs[qg[x].size()+qg[y].size()].clone()/se[_.data=op]))]),l[e(x)=_.macroexpand(x)] in _.macro/se[_(qs[_&&_],rxy(qse[qg[l[xp=x][xp&&xp.size()?y:xp]]])),_(qs[_||_],rxy(qse[qg[l[xp=x][xp&&xp.size()?xp:y]]])),_(qs[_===_],rxy(qs[qg[l[xp=x,yp=y][xp===yp||xp.size()===yp.size()&&xp.zip(yp).forall(fn[p][p[0]===p[1]])]]])),_(qs[_!==_],rxy(qs[qg[l[xp=x,yp=y][xp!==yp&&(xp.size()!==yp.size()||xp.zip(yp).exists(fn[p][p[0]!==p[1]]))]]])),_(qs[_^_],rxy(qs[x.zip(y)])),_(qs[_+_],rxy(qs[x.concat(y)])),_(qs[ !_],rxy(qs[x.object()])),_(qs[_,_],rxy(qs[x,y])),_(qs[ ~_],rxy(qs[new r(x)].as(\'(\').replace({r:new this.ref(this.seq.finite)}))),_(qs[_?_:_],fn[x,y,z][qs[x?y:z].replace({x:e(x),y:e(y),z:e(z)})]),l[rx(t)(x,y)=t.replace({x:e(x),y:y})][_(qs[_(_)],rx(qs[x(y)])),_(qs[_[_]],rx(qs[x[y]])),_(qs[_._],rx(qs[x.y])),_(qs[_].as(\'(\'),rx(qs[qg[x]]))],_(qs[ +_],fn[x][x]),seq(qw(\'sk sv sp\')).zip(qw(\'keys values pairs\')).each(fb[p][_(qs[p[_]].replace({p:p[0]}),fb[x][qs[r(x)].replace({r:new this.ref(this.seq.finite[p[1]]),x:x})])])],this.rmacro(qs[seq[_]],_.macroexpand),where*[template(op)(t)=qs[_+x].replace({x:t})/se[_.data=op],qw=caterwaul.util.qw,not=new this.ref(fn[f][fn_[ !f.apply(this,arguments)]]),trees_for(op)=op.charAt(op.length-1)===\'!\'?seq([qs[ ![_]],qs[ !_[_]],qs[ ! ~[_]],qs[ ! ~_[_]],qs[ ! +_]]).map(template(op.substring(0,op.length-1))):seq([qs[[_]],qs[_[_]],qs[ ~[_]],qs[ ~_[_]],qs[ +_]]).map(template(op)),rxy(tree)(x,y)=tree.replace({x:_.macroexpand(x),y:y&&_.macroexpand(y)}),seq=fb[xs][new this.seq.finite(xs)]]]}).configuration(\'seq\',function (){this.configure(\'seq.core seq.finite.core seq.finite.object seq.finite.mutability seq.finite.traversal seq.finite.zip seq.finite.quantification \'+\'seq.finite.serialization seq.infinite.core seq.infinite.y seq.infinite.transform seq.infinite.traversal seq.dsl\')});caterwaul.tconfiguration(\'std seq\',\'heap\',function (){this.heap(less)=fc_[null]/se.c[c.prototype=new caterwaul.seq.finite()/se[_.constructor=c]/se[_.insert(x)=this.push(x).heapify_up(this.size()-1),_.root()=this[0],_.rroot()=this[0]/se[this.pop()/se[this[0]=_,this.heapify_down(0),when[this.size()]]],_.swap(i,j)=this/se[_[j]=_[i],_[i]=temp,where[temp=_[j]]],_.heapify_up(i)=this/se[_.swap(i,p).heapify_up(p),when[less.call(_,_[i],_[p])],where[p=i>>1]],_.heapify_down(i)=this/se[_.swap(lr,i).heapify_down(lr),unless[lr===i],where*[s=_.size(),r=i+1<<1,l=r-1,ll=l<s&&less.call(_,_[l],_[i])?l:i,lr=r<s&&less.call(_,_[r],_[ll])?r:ll]]]]});caterwaul.tconfiguration(\'std seq continuation\',\'memoize\',function (){this.namespace(\'memoize\')/se.m[m.wrap(f)=fn_[l[as=arguments,start= +new Date()] in unwind_protect[{error:e}][{result:f.apply(this,as)}]/se[_.time= +new Date()-start]]/se[_.original=f],m.perform(result)=result.error?unwind[result.error]:result.result,m.from(proxy)=fn[f][l[state={},g=m.wrap(f)] in fn_[m.perform(proxy.call(state,this,arguments,g))]]]});caterwaul.tconfiguration(\'std seq continuation memoize\',\'parser.core\',function (){this.namespace(\'parser\')/se[_.parse_state(input,i,result,memo)=undefined/se[this.input=input,this.i=i,this.result=result,this.memo=memo],_.parse_state/se.s[s.from_input(input)=new _.parse_state(input,0,null,{}),s.prototype/se[_.accept(i,r)=new this.constructor(this.input,i,r,this.memo),_.has_input()=this.i<this.input.length,_.toString()=\'ps[#{this.input.substr(this.i)}, #{this.result}]\']],_.memoize=caterwaul.memoize.from(fn[c,as,f][k in m?m[k]:(m[k]=f.apply(c,as)),where[k=\'#{f.original.memo_id}|#{as[0].i}\',m=as[0].memo||(as[0].memo={})]]),_.promote_non_states(f)=fn[state][state instanceof _.parse_state?f.call(this,state):f.call(this,_.parse_state.from_input(state))/re[_&&_.result]],_.identify(f)=f/se[_.memo_id=caterwaul.gensym()],_.parser(f)=_.promote_non_states(_.memoize(_.identify(f))),_.defparser(name,f)=_.parsers[name]()=_.parser(f.apply(this,arguments)),_.parsers={}]}).tconfiguration(\'std seq continuation\',\'parser.c\',function (){this.configure(\'parser.core\').parser.defparser(\'c\',fn[x,l][x.constructor===String?fn[st][st.accept(st.i+x.length,x),when[x===st.input.substr(st.i,x.length)]]:x instanceof Array?l[index=index_entries(x)] in fn[st][check_index(index,st.input,st.i)/re[_&&st.accept(st.i+_.length,_)]]:x.constructor===RegExp?l[x=add_absolute_anchors_to(x)] in fn[st][fail_length(x,st.input,st.i,l)/re[_>l&&split_lengths(x,st.input,st.i,l,_)/re[st.accept(st.i+_,x.exec(st.input.substr(st.i,_)))]]]:x.constructor===Function?fn[st][x.call(st,st.input,st.i)/re[_&&st.accept(st.i+_,st.input.substr(st.i,_))]]:l[index=index_entries(seq[sk[x]])] in fn[st][check_index(index,st.input,st.i)/re[_&&st.accept(st.i+_.length,x[_])]],where*[check_index(i,s,p)=seq[i|[_[\'@#{s}\']&&s,where[s=s.substr(p,_.length)]]],index_entries(xs)=l*[xsp=seq[ ~xs],ls=seq[sk[seq[ !(xsp*[[_.length,true]])]]*[Number(_)]]] in seq[ ~ls.slice().sort(fn[x,y][y-x])* ~l[ !(xsp%[_.length===l]*[[\'@#{_}\',true]]+[[\'length\',l]])]],add_absolute_anchors_to(x)=l[parts=/^\\/(.*)\\/(\\w*)$/.exec(x.toString())] in new RegExp(\'^#{parts[1]}$\',parts[2]),fail_length(re,s,p,l)=re.test(s.substr(p,l))?p+(l<<1)<=s.length?fail_length(re,s,p,l<<1):l<<1:l,split_lengths(re,s,p,l,u)=l*[b(l,u)=l+1<u?(l+(u-l>>1))/re.m[re.test(s.substr(p,m))?b(m,u):b(l,m)]:l] in b(l,u)]])}).tconfiguration(\'std opt seq continuation\',\'parser.seq\',function (){this.configure(\'parser.core\').parser.defparser(\'seq\',fn_[l[as=arguments] in fn[state][call/cc[fn[cc][opt.unroll[i,as.length][(state=as[i](state))?result.push(state.result):cc(false)],state.accept(state.i,result)]],where[result=[]]]])}).tconfiguration(\'std seq\',\'parser.alt\',function (){this.configure(\'parser.core\').parser.defparser(\'alt\',fn_[l[as=seq[ ~arguments]] in fn[state][seq[as|[_(state)]]]])}).tconfiguration(\'std opt seq continuation\',\'parser.times\',function (){this.configure(\'parser.core\').parser.defparser(\'times\',fn[p,lower,upper][fn[state][call/cc[fn[cc][opt.unroll[i,lower][ ++count,(state=p(state))?result.push(state.result):cc(false)],true]]&&call/cc[l*[loop(cc)=( !upper||count++<upper)&&state.has_input()&&p(state)/se[state=_,when[_]]?result.push(state.result)&&call/tail[loop(cc)]:cc(state.accept(state.i,result))] in loop],where[count=0,result=[]]]])}).tconfiguration(\'std seq continuation\',\'parser.opt\',function (){this.configure(\'parser.core\').parser.defparser(\'opt\',fn[p][fn[state][state.accept(n,r),where*[s=p(state),n=s?s.i:state.i,r=s&&s.result]]])}).tconfiguration(\'std seq continuation\',\'parser.match\',function (){this.configure(\'parser.core\').parser/se[_.defparser(\'match\',fn[p][fn[state][p(state)/re[_&&state.accept(state.i,state.result)]]]),_.defparser(\'reject\',fn[p][fn[state][p(state)/re[ !_&&state.accept(state.i,null)]]])]}).tconfiguration(\'std seq continuation\',\'parser.bind\',function (){this.configure(\'parser.core\').parser/se[_.defparser(\'bind\',fn[p,f][fn[state][p(state)/re[_&&_.accept(_.i,f.call(_,_.result))]]])]}).tconfiguration(\'std seq continuation\',\'parser.dsl\',function (){this.configure(\'parser.core\').rmacro(qs[peg[_]],fn[x][qs[qg[l*[_bindings][_parser]]].replace({_bindings:new this.syntax(\',\',seq[sp[this.parser.parsers]*[qs[_x=_y].replace({_x:_[0],_y:new outer.ref(_[1])})]]),_parser:this.parser.dsl.macroexpand(x)}),where[outer=this]]),this.parser.dsl=caterwaul.global().clone()/se.dsl[dsl.macro/se[_(qs[_(_)],fn[x,y][qs[_x(_y)].replace({_x:e(x),_y:y})]),_(qs[_/_],fb(\'/\',\'alt\')),_(qs[_%_],fb(\'%\',\'seq\')),_(qs[_>>_],b(\'bind\')),_(qs[[_]],u(\'opt\')),_(qs[_].as(\'(\'),fn[x][e(x).as(\'(\')]),_(qs[_[_]],fn[x,l][qs[times(_x,_l)].replace({_x:e(x),_l:l})]),_(qs[_[_,_]],fn[x,l,u][qs[times(_x,_l,_u)].replace({_x:e(x),_l:l,_u:u})]),where*[e=dsl.macroexpand,fb(op,name)(x,y)=qs[_name(_x,_y)].replace({_name:name,_x:x.flatten(op).map(e)/se[_.data=\',\'],_y:e(y)}),b(name)(x,y)=qs[_name(_x,_y)].replace({_name:name,_x:e(x),_y:y}),u(name)(x)=qs[_name(_x)].replace({_name:name,_x:e(x)})]]]}).configuration(\'parser\',function (){this.configure(\'parser.core parser.c parser.seq parser.alt parser.times parser.opt parser.match parser.bind parser.dsl\')});');
meta::cached_dependency('jquery.gaussian.js', <<'__');
// Gaussian Blur jQuery plugin | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// This plugin provides a gaussian() method for DOM elements. It uses the element's position as the center and can be parameterized by the blur width (the 'c' parameter in the Gaussian function,
// http://en.wikipedia.org/wiki/Gaussian_function). Numerical integration is performed to make sure that the area under the curve is roughly one; thus, the limit as c -> 0 is the original
// element.

// Elements may be blurred directionally in one or two dimensions. For the two-dimensional case, the blur is convolved across each directional vector. Since each integral will be one, the
// integral of the convolution will also be one.

// By the way, the continuous Gaussian function used here is not quite optimal. A better one is the discrete Gaussian function based on the complex-valued Bessel function. However, the continuous
// Gaussian is easier to implement so I'm using that instead. It's only a web UI, after all :)

(function ($) {
  var gaussian_function  = function (c, x)     {return Math.exp (-(x * x) / (2.0 * c * c))},
      linear_sequence    = function (x0, d, n) {var xs = []; for (var i = 0; i < n; ++i) xs.push (x0 + i * d); return xs},
      centered_sequence  = function (d, n)     {return linear_sequence (-d * (n - 1) / 2.0, d, n)},
      gaussian_sequence  = function (c, n)     {return $.map (centered_sequence (c * 6.0 / n, n), function (x) {return gaussian_function (c, x)})},
      normalized         = function (xs)       {var total = 0; $.each (xs, function (i, x) {total += x}); return $.map (xs, function (x) {return x / total})};

//   The do_gaussian_blur() function.
//   This function creates and returns a new array of elements, each a clone of e, and scales their opacity and offsets them by appropriate distances. dx and dy mark the extremities of the
//   transformation (which is symmetric around the original element), and n specifies how many copies to create. The Gaussian distribution is automatically scaled such that three standard
//   deviations are accounted for.

  var do_gaussian_blur = function (e, n, dx, dy) {
    var position  = $(e).position(),
        opacity   = $(e).css('opacity'),
        positions = $.map (centered_sequence (1.0 / n, n), function (t) {return {left: position.left + t * dx, top: position.top + t * dy}}),
        opacities = normalized (gaussian_sequence (3.0, n)),
        parent    = $(e).parent(),
        elements  = $();

    $.each (positions, function (i, p) {elements = elements.add ($(e).clone (false).attr ('id', '').addClass ('gaussian-clone').appendTo (parent).
                                                                        css ({position: 'absolute', opacity: opacity * opacities[i], visibility: 'visible', left: p.left, top: p.top}))});
    return elements};

//   The unblur() function.
//   Removes all clones from the document and restores the visibility of the original element.

  var unblur = function () {$(this).data('gaussian-clones') ? $(this).css({visibility: 'visible'}).data('gaussian-clones').each (unblur) && unblur.call ($(this).removeData ('gaussian-clones'))
                                                            : $(this).filter('.gaussian-clone').remove()};

//   The gaussian() function.
//   This is the jQuery interface function. gaussian() replaces each matched element by an array of clones designed to create a blurring effect. The new elements will have the class
//   'gaussian-clone' in addition to any classes the original element had. The original element is not removed from the document, but hidden. Calling gaussian() on an already-blurred element will
//   blur each of the clones, allowing for multiple-vector convolution. For example:

//   | $('div').gaussian({dx: 5, n: 10}).           // Blur 10 pixels along x axis, using 10 copies (radius is 5px)

//   As a special case, you can pass in null as the options hash to unblur an element. This removes all clones from the document and restores the original to a visible state. It removes clones
//   from all subsequent blurring as well.

//   Options.
//     dx, dy: The horizontal and vertical components of the vector to blur with. Distance matters; the distance of the vector <dx, dy> is the distance of the 1 -> 0 opacity fade.
//             By default, dx = 0 and dy = 0.
//     n:      The number of clones to use.
//             By default, n = 5.

  $.fn.gaussian = function (options) {
    return $(this).each (options === null ? unblur
                                          : function (i, e) {$(e).data('gaussian-clones') ? $(e).data('gaussian-clones').each (function () {$(this).gaussian (options)})
                                                                                          : $(e).data('gaussian-clones', do_gaussian_blur (e, options.n || 5, options.dx || 0, options.dy || 0)).
                                                                                                  css({visibility: 'hidden'})})};

//   The gaussians() function.
//   Returns the elements that are used to represent the blurred element. This is basically the clones, plus any clones of theirs. This function doesn't take any options, and it doesn't include
//   the element on which it was called.

  $.fn.gaussians = function () {var collection = $(); this.each(function () {var xs = $(this).data('gaussian-clones') || [];
                                                                             for (var i = 0, l = xs.length; i < l; ++i) collection = collection.add(xs[i]).add($(xs[i]).gaussians())});
                                return collection};

//   The motionblur() function.
//   This function moves the element, blurring it as it is moving. When the animation finishes the blur is removed. It takes two positional options, 'left' and 'top', which specify the position
//   the element should move to. It also optionally takes an 'n' to provide to the gaussian() function (by default this is 8) and a 'sharpness' that determines what fraction of the distance is
//   used to blur. By default elements have a sharpness of 10. Other optional parameters are 'speed', which is passed into jQuery's animate() function, 'easing', which is also passed into
//   animate(), and 'callback', which is invoked after the animation and unblurring are complete.

//   All positions are relative to the offset parent, not to the document.

  $.fn.motionblur = function (options) {
    return $(this).each (function () {var p = $(this).position(), dx = options.left - p.left, dy = options.top - p.top;
                                      $(this).gaussian({dx: dx / (options.sharpness || 10), dy: dy / (options.sharpness || 10), n: options.n || 8}).gaussians().add(this).
                                                   css({position: 'absolute'}).
                                               animate({left: (dx >= 0 ? '+=' : '-=') + Math.abs(dx), top: (dy > 0 ? '+=' : '-=') + Math.abs(dy)},
                                                       options.speed || $.fx.speeds._default, options.easing || 'swing', function () {
                                                                                                                           $(this).gaussian(null).css({left: options.left, top: options.top});
                                                                                                                           options.callback && options.callback.call(this)})})};
}) (jQuery);

// Generated by SDoc 
__
meta::cached_dependency('jquery.instavalidate.js', <<'__');
// Text field instavalidate | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// This plugin gives you really easy validation for text fields. For example:

// | $('input.zip').instavalidate(/\d{5}(\d{4})?/);
//   $('input.name').instavalidate(function (value) {return name.charAt(0) === name.charAt(0).toUpperCase()});

// You can also configure asynchronous validation:

// | $('input.name').instavalidate(function (value, callback) {
//     $.getJSON('/names', function (names) {
//       callback(names.indexOf(value) > -1);
//     });
//   });

// There aren't conflicts if you do it the asynchronous way; that is, if AJAX call 2 returns before AJAX call 1, AJAX call 1's callback won't overwrite AJAX call 2's validation. (Basically, this
// works the way you'd want it to.)

// Configuration.
// There are a few options you can set:

// | 1. className: The CSS class to use to mark a field as invalid. Defaults to 'invalid'.
//   2. invalid: A function to be called when the field transitions from valid to invalid. Defaults to null.
//   3. valid: A function to be called when the field transitions from invalid to valid. Defaults to null.
//   4. delay: How many milliseconds to wait after the last keystroke before validating. Defaults to 0.
//   5. immediate: Whether to update on each keystroke. If false, the validation status will be updated only on blur. Defaults to true.

(function ($) {
  var defaults = {className: 'invalid', invalid: null, valid: null, delay: 0, immediate: true};
  
  $.fn.instavalidate = function (validator, options) {
    var validate_function = validator.constructor === RegExp ? function (value) {return validator.test(value)} : validator;
    options = $.extend({}, defaults, options || {});

    return this.each(function () {
      var timeout = null, presently_valid = true, asynchronous_counter = 0;
      var validator = function () {
        var t = $(this);

        timeout && clearTimeout(timeout);
        timeout = setTimeout(function () {
          timeout = null;

          var asynchronous_id = ++asynchronous_counter;
          var callback        = function (valid) {
            if (asynchronous_id === asynchronous_counter && presently_valid !== (presently_valid = valid))
              if (presently_valid) {
                t.removeClass(options.className);
                options.valid && options.valid.call(t);
              } else {
                t.addClass(options.className);
                options.invalid && options.invalid.call(t);
              }
          };

          var result = validate_function.call(t, t.val(), callback);
          result === undefined || callback(result);
        }, options.delay);
      };

      $(this).blur(validator);
      options.immediate && $(this).keyup(validator);
      options.immediate && validator.call(this);
    });
  };
})(jQuery);

// Generated by SDoc 
__
meta::cached_dependency('montenegro.client.js', <<'__');
// Montenegro client-side bindings | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// Montenegro works with jQuery to add structure to user interfaces and define useful shorthands for common cases. It also provides a Javascript markup language that you can use to build
// interfaces instead of going the HTML route. For logic-heavy applications this may make more sense than separating the layout.

// JQuery extension methods.
// These are used throughout Montenegro. up() takes either a selector or a number. If you give it a selector, it grabs the nearest matching parent; if you give it a number, it traverses up that
// many parents. The nearest() method lets you do approximate matching. For example, suppose you have this setup:

// | div.foo(div > textarea, div > button.save)

// If you want the save button to see the textarea (e.g. from inside a click handler), the obvious solution is $(this).parent().find('textarea'). However, that's a lot of work and doesn't scale
// well if the DOM layout changes. Better is to say $(this).nearest('textarea'). Note that it doesn't actually return just the single nearest one. It just goes up until it starts finding
// textareas. Note that .nearest() is O(n^2) and average-case n log n in the number of nodes in the document.

// The cval() method returns and then clears the value of a component. If you give it a parameter, the value will be cleared to that value rather than set to the empty string.

  caterwaul.tconfiguration('std', 'montenegro.methods', function () {jQuery.fn /se[_.up(s)      = s instanceof Number ? s ? this.parent().up(s - 1) : this : this.parents(s).eq(0),
                                                                                   _.cval(nv)   = l[v = this.val()] in this.val(nv || '') /re[v],
                                                                                   _.nearest(s) = this.length ? this.find(s) /re[_.length ? _ : this.parent().nearest(s)] : jQuery([])]}).

//   Event extensions.
//   Some events are common enough that it's useful to have a handler for them. Hitting the enter key is one of those. Another is getting a link to have a click action and look active, but not
//   actually go anywhere.

    tconfiguration('std', 'montenegro.events', function () {jQuery.fn /se[_.enter_key(f) = this.keyup(fn[e][e.which === 13 && f.call(this, e)]),
                                                                          _.clickable(f) = this.attr('href', 'javascript:void(0)').click(f)]}).

//   Fixes.
//   These are fixes for places where jQuery is somehow suboptimal. Examples include extensions to support variadic/pluralized append(), prepend(), before(), and after(), and various fixes for
//   the clone() method. These fixes are still maintained in other Github repositories:

//   | http://github.com/spencertipping/jquery.fix.append-multiple
//     http://github.com/spencertipping/jquery.fix.select-clone
//     http://github.com/spencertipping/jquery.fix.textarea-clone

    tconfiguration('std seq continuation', 'montenegro.fixes', function () {
    jQuery /se[_.from_many() = l[as = arguments] in _([]) /se.r[seq[~as *![_ instanceof Array || _ instanceof jQuery ? seq[~_ *![r.push(_)]] : r.push(_)]]]],
    jQuery.fn /se[
      l*[tn         = document/mb/createTextNode,
         multi(f)() = l[xs = arguments] in this /se.t[seq[~xs *![_ instanceof Array ? multi(f).apply(t, _.slice()) : f.call(t, _), unless[_ == null]]]]] in
      seq[~'append before after prepend'.split(/\s+/) *!m[_[m] = multi(_[m])]],

      _.clone() = clone.call(this) /se[seq[(~this.find(fill) *+$ ^ ~_.find(fill) *+$) *![_[0].val(_[1].val())]]], where[$ = jQuery, fill = 'select, textarea', clone = _.clone]]}).

// RPC tunneling.
// You can connect to a server endpoint with a CPS-converted proxy function. You can also send opaque references to the server (presumably so that it can send them back). Here's an example of
// passing a DOM node:

// | var identity = montenegro.rpc('/identity-function');
//   var body     = $('body');
//   identity(montenegro.rpc.ref(body), fn[result][montenegro.rpc.ref(result).append('Got the body element back')]);
//   // alternatively:
//   l/cps[result <- identity(montenegro.rpc.ref(dom_node), _)][montenegro.rpc.ref(result).append('Got the body element back')];

// Assuming that the server replies with the data it was given, this will append some text to the document body when the server replies. The mechanism for this is actually really simple;
// montenegro.rpc.ref() just assigns a new gensym to each value you alias; that string goes to the server and is later resolved back into the client-side value. (This is why the server won't be
// able to do anything useful with the value.) Montenegro automatically garbage-collects the reference table by deallocating a reference when you dereference it. (So you can't dereference
// something more than once; if you do this it will create a new reference instead.)

//   Example: Building a chat client.
//   In montenegro.server.js.sdoc there's an example of a broadcast chat server. Here's the corresponding client code and some DOM nodes to make it work:

//   | var send = caterwaul.montenegro.rpc('/chat/send');
//     caterwaul.montenegro.rpc('/chat')(fn[message][$('.log').append(html[div.message(message)]), this()]);
//     $('body').append(html[div(div.log, button('Send'), input]));         // This just builds the UI. You could also do this with regular HTML.
//     l/cps[_ <- $('button').click(_)][send($('#input').cval())];

//   The 'this()' invocation inside the callback is used when you want to send something back and reuse the callback function. I'm using it here to avoid having to refer to the callback function
//   in a first-class way (which would normally be necessary to set the cycle up again).

    tconfiguration('std seq', 'montenegro.rpc', function () {
      this.namespace('montenegro') /se[
        _.rpc(url)() = l[as = seq[~arguments]][l*[callback = as.length && as[as.length - 1] /re[_.constructor === Function && as.pop()]] in
                                               $.ajax({url: url, type: 'POST', contentType: 'application/json', data: JSON.stringify(as.slice()), dataType: 'json',
                                                   success: fn[reply][callback && callback.apply(fn_[_.rpc(url).apply(null, seq[~arguments].slice().concat([callback]))], reply)]})]]}).

// DOM construction.
// You can build elements using a CSS-selector-style syntax. (Alternatively, you can provide an element in the markup; if you do it this way, the template element's ID should match the model
// name.) So, for example, suppose we're modeling a person with a name and e-mail address. Here's what the markup might look like in HTML:

// | <div id='person' class='person'>
//     <label for='name1'>Name:</label>
//     <input id='name1' class='name nonempty' />
//     <label for='email1'>Email:</label>
//     <input id='email1' class='email' />
//     <a class='facebook' href='http://facebook.com/someone'>A Facebook Page</a>
//   </div>

// | html[div.person(input.name.nonempty, input.email, a.facebook /attr('href', 'http://facebook.com/someone') > 'A Facebook Page')]

// Note that you can't use hyphens in the class names in Javascript, but if you type underscores they'll be converted into dashes. For example:

// | html[div.first_name]          // becomes <div class='first-name'></div>

//   Automation and event handlers.
//   You can get the jQuery shell for an element by using the '/' operator. The right-hand side is an invocation on the jQuery shell; for example:

//   | $('<a>').addClass('foo').click(fn_[...]).mouseover(fn_[...])
//     // can be written as:
//     html[a.foo /click(fn_[...]).mouseover(fn_[...])]

//   Anything after a '/' for an element is not considered to be HTML, so you'll have to use another html[] if you want to create elements to pass into a jQuery function. For example:

//   | html[a.foo /append(span('some text'))]              // won't do what you want
//     html[a.foo /append(html[span('some text')])]        // this is the right way to do it
//     html[a.foo > span('some text')]                     // even better

//   Evaluating subexpressions.
//   Going back to the person example, suppose you have a list of people that you want to insert into a div. Here's what that looks like:

//   | var people = seq[...];
//     var person = fn[p][html[div.person(input.name.nonempty /val(p.name))]];
//     var ui     = html[div.people(people.map(person), button.save('Save'), button.cancel('Cancel'))];

//   Here, the expression 'people.map(person)' gets evaluated as a Javascript expression rather than as markup. Montenegro knows to do this because 'people' isn't one of the HTML elements it
//   knows about. Javascript expressions should return strings, sequences, arrays, or jQuery objects. Strings get promoted into text nodes, so you don't have to worry about HTML escaping.

//   Mapping.
//   You can map an element through a function using the '%' shorthand. For example:

//   | var nonempty = fn_[this.instavalidate(/^.+$/)];
//     var ui = html[div(input.name %nonempty, input.title %nonempty)]

//   This isn't quite the same thing as side-effecting. Using the map shorthand replaces the element with whatever your map function returns, which may or may not be desirable.

//   Note that tempting as it is, you can't say this:

//   | html[div((input.name, input.title) %nonempty)]       // can't do this, even though it would be awesome

//   I considered adding a distributive property, but Javascript's syntax is restrictive enough that I don't think it makes sense. It also makes you think too hard about your markup, which isn't
//   a good thing. The markup should be simple and local, and your modifier functions should be short enough to type several times. (This can be achieved by using a let-binding or similar.)

//   Evaluation contexts.
//   Containment can be specified either as div(x) or by div > x. If you want 'x' to be evaluated as Javascript code rather than HTML, you can use >=, for instance div >= x. (Think of <% vs. <%=
//   in ERB or ASP.) Specifying multiple children is possible too; you use div >= [x, y, z]. (Using div >= (x, y, z) will evaluate (x, y, z) as JS, which returns just z.)

//   Note that because > and >= are left-associative, a > b > c will add b and c to a rather than adding c to b, then b to a.

//   Attributes.
//   You can define attributes by using one form of the * syntax:

//   | html[a.foo *href('http://www.google.com')]

//   As usual, underscores are replaced by hyphens -- most HTML attributes don't contain underscores.

//   Context inference.
//   There's a little bit of guessing that goes on about what's what. Usually the guesser gets things right, but there are some older HTML nodes that it doesn't detect. For example:

//   | html[div.foo > people.map(person)]          // div.foo is an element, people.map(person) is a function call -- its return value will be appended to the div
//     html[a.code > b.code > 'foo']               // a.code is a link with class 'code' that contains the Javascript value 'b.code' and the text 'foo'
//     html[div, foo, bar(bif), code('bar')]       // a div, the value 'foo', the function 'bar' called on bif, and a <code> element containing the text 'bar'

//   The complete list is in caterwaul.montenegro.dom.elements; setting additional keys in this hash to truthy values causes those identifiers to be treated as valid HTML elements. (I mention
//   this because at the moment the HTML5 standard isn't completely listed.)

//   Subtleties of this macroexpander.
//   There's only one thing that's particularly subtle and crucial to how this works. That's the detail of the qs[_] matcher, which is the first macro defined for the DOM expander. This macro
//   isn't written as a conditional because we never want the macroexpansion to descend as it normally would. Rather, we drive the descent using explicit calls to macroexpand(). Therefore, qs[_]
//   must always claim to have replaced the syntax with something; thus the failure case is just identity, indicating a success and no macro-driven descent.

    tconfiguration('std seq continuation', 'montenegro.dom', function () {
      this.configure('montenegro.fixes montenegro.methods').namespace('montenegro').dom = this.global().clone() /se[
        this.rmacro(qs[html[_]], _) /cps.t[qs[jQuery.from_many(_x)].replace({_x: _.macroexpand(t)})],

        _.elements = this.util.qw('html head body meta script style link title div a span input button textarea option select form label iframe blockquote code caption ' +
                                  'table tbody tr td th thead tfoot img h1 h2 h3 h4 h5 h6 li ol ul noscript p pre samp sub sup var canvas audio video') /re[seq[!(~_ *[[_, _]])]],

        l*[ref(x) = new this.ref(x), expand = _.macroexpand, is_an_element(tree) = _.elements[tree.data] || tree[0] && is_an_element(tree[0]), htmlify(s) = s.replace(/_/g, '-')] in

        _.macro /se[_(qs[_], fn[x][e ? qs[jQuery(document.createElement(_tag))].replace({_tag: '"#{e}"'}) : x, where[e = is_an_element(x)]]),

                    _(qs[_(_)], appender(expand, expand)), _(qs[_[_]], appender(expand, id)), _(qs[_ > _], appender(expand, expand)), _(qs[_ >= _], appender(expand, id)),
                    where[id(x) = x, appender(f, g)(t1, t2) = is_an_element(t1) && qs[_e.append(_c)].replace({_e: f(t1), _c: g(t2)})],

                    _(qs[[_]],  fn     [t][qs[[_e]]  .replace({_e: expand(t)})]),          _(qs[_, _], fn[t1, t2][qs[_1, _2].replace({_1: expand(t1), _2: expand(t2)})]),
                    _(qs[_ %_], fn[t1, t2][qs[_f(_e)].replace({_e: expand(t1), _f: t2})]), _(qs[_ /_], fn[t1, t2][qs[_e._f] .replace({_e: expand(t1), _f: t2})]),

                    _(qs[_ *_(_)], fn[e, a, v][qs[_e.attr(_a, _v)].replace({_e: expand(e),  _a: '"#{htmlify(a.data)}"', _v: v}), when[is_an_element(e)]]),
                    _(qs[_._],     fn [t1, t2][qs[_e.addClass(_c)].replace({_e: expand(t1), _c: '"#{htmlify(t2.data)}"'}),       when[is_an_element(t1)]])]]}).

// Final configuration.
// This one loads all of the others (though it lets you specify whether you want indirected references or not).

  configuration('montenegro', function () {this.configure('montenegro.methods montenegro.events montenegro.fixes montenegro.rpc montenegro.dom')});

// Generated by SDoc 
__
meta::configuration('dependencies', <<'__');
# Named dependencies:
caterwaul.all.js:        http://spencertipping.com/caterwaul/caterwaul.all.min.js
montenegro.client.js:    http://spencertipping.com/montenegro/montenegro.client.js
jquery.instavalidate.js: http://spencertipping.com/jquery.instavalidate/jquery.instavalidate.js
jquery.gaussian.js:      http://spencertipping.com/jquery.gaussian/jquery.gaussian.js
__
meta::data('default-action', 'shell');
meta::data('libraries', <<'__');
# URLs of libraries to be downloaded into the lib/ directory.
http://spencertipping.com/caterwaul/caterwaul.all.js
http://spencertipping.com/montenegro/montenegro.server.js
__
meta::data('license', <<'__');
MIT License
Copyright (c) 2010 Spencer Tipping

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
__
meta::data('main', 'server.js');
meta::data('permanent-identity', 'deb5a950b48eb0021bed278d045d76cd');
meta::data('quiet', '1');
meta::data('watching', '1');
meta::function('alias', <<'__');
my ($name, @stuff) = @_;
return ls('-a', '^alias::') unless defined $name;
@stuff ? around_hook('alias', @_, sub {associate("alias::$name", join ' ', @stuff)}) : retrieve("alias::$name") || "Undefined alias $name";
__
meta::function('cat', 'join "\\n", retrieve(@_);');
meta::function('cc', <<'__');
# Stashes a quick one-line continuation. (Used to remind me what I was doing.)
@_ ? associate('data::current-continuation', hook('set-cc', join(' ', @_))) : retrieve('data::current-continuation');
__
meta::function('ccc', 'rm(\'data::current-continuation\');');
meta::function('child', <<'__');
around_hook('child', @_, sub {
  my ($child_name) = @_;
  clone($child_name);
  enable();
  qx($child_name update-from $0 -n);
  disable()});
__
meta::function('clone', <<'__');
for (grep length, @_) {
  around_hook('clone', $_, sub {
    hypothetically(sub {
      rm('data::permanent-identity');
      file::write($_, serialize(), noclobber => 1);
      chmod(0700, $_)})})}
__
meta::function('cp', <<'__');
my $from = shift @_;
my $value = retrieve($from);
associate($_, $value) for @_;
__
meta::function('create', <<'__');
my ($name, $value) = @_;
around_hook('create', $name, $value, sub {
  return edit($name) if exists $data{$name};
  associate($name, defined $value ? $value : '');
  edit($name) unless defined $value});
__
meta::function('current-state', 'serialize(\'-pS\');');
meta::function('disable', 'hook(\'disable\', chmod_self(sub {$_[0] & 0666}));');
meta::function('dupdate', <<'__');
# Update the repository based on the dependencies it lists.
use LWP::Simple ();
rm(grep /^cached_dependency::/, keys %data);
my %dependencies = dependencies();

for (keys %dependencies) {
  terminal::info("Retrieving $dependencies{$_} as $_");
  associate("cached_dependency::$_", LWP::Simple::get($dependencies{$_}))}
__
meta::function('edit', <<'__');
my ($name, %options) = @_;
my $extension = extension_for($name);

die "$name is virtual or does not exist" unless exists $data{$name};
die "$name is inherited; use 'edit $name -f' to edit anyway" unless is($name, '-u') || is($name, '-d') || exists $options{'-f'};

around_hook('edit', @_, sub {
  associate($name, invoke_editor_on($data{$name} || "# Attribute $name", %options, attribute => $name, extension => $extension),
            execute => $name !~ /^bootstrap::/)});
save() unless $data{'data::edit::no-save'};
'';
__
meta::function('enable', 'hook(\'enable\', chmod_self(sub {$_[0] | $_[0] >> 2}));');
meta::function('export', <<'__');
# Exports data into a text file.
#   export attr1 attr2 attr3 ... file.txt
my $name = pop @_;
@_ or die 'Expected filename';
file::write($name, join "\n", retrieve(@_));
__
meta::function('extern', '&{$_[0]}(retrieve(@_[1 .. $#_]));');
meta::function('grep', <<'__');
# Looks through attributes for a pattern. Usage is grep pattern [options], where
# [options] is the format as provided to select_keys.

my ($pattern, @args)     = @_;
my ($options, @criteria) = separate_options(@args);
my @attributes           = select_keys(%$options, '--criteria' => join('|', @criteria));

$pattern = qr/$pattern/;

my @m_attributes;
my @m_line_numbers;
my @m_lines;

for my $k (@attributes) {
  next unless length $k;
  my @lines = split /\n/, retrieve($k);
  for (0 .. $#lines) {
    next unless $lines[$_] =~ $pattern;
    push @m_attributes,   $k;
    push @m_line_numbers, $_ + 1;
    push @m_lines,        '' . ($lines[$_] // '')}}

unless ($$options{'-C'}) {
  s/($pattern)/\033[1;31m\1\033[0;0m/g for @m_lines;
  s/^/\033[1;34m/o for @m_attributes;
  s/^/\033[1;32m/o && s/$/\033[0;0m/o for @m_line_numbers}

table_display([@m_attributes], [@m_line_numbers], [@m_lines]);
__
meta::function('hash', 'fast_hash(@_);');
meta::function('hook', <<'__');
my ($hook, @args) = @_;
$transient{active_hooks}{$hook} = 1;
dangerous('', sub {&$_(@args)}) for grep /^hook::${hook}::/, sort keys %data;
@args;
__
meta::function('hooks', 'join "\\n", sort keys %{$transient{active_hooks}};');
meta::function('identity', 'retrieve(\'data::permanent-identity\') || associate(\'data::permanent-identity\', fast_hash(rand() . name() . serialize()));');
meta::function('import', <<'__');
my $name = pop @_;
associate($name, @_ ? join('', map(file::read($_), @_)) : join('', <STDIN>)); 
__
meta::function('import-bundle', <<'__');
eval join '', <STDIN>;
die $@ if $@;
__
meta::function('initial-state', '$transient{initial};');
meta::function('is', <<'__');
my ($attribute, @criteria) = @_;
my ($options, @stuff) = separate_options(@criteria);
attribute_is($attribute, %$options);
__
meta::function('load-state', <<'__');
around_hook('load-state', @_, sub {
  my ($state_name) = @_;
  my $state = retrieve("state::$state_name");

  terminal::state('saving current state into _...');
  &{'save-state'}('_');

  delete $data{$_} for grep ! /^state::/, keys %data;
  %externalized_functions = ();

  terminal::state("restoring state $state_name...");
  meta::eval_in($state, "state::$state_name");
  terminal::error(hook('load-state-failed', $@)) if $@;
  reload();
  verify()});
__
meta::function('loc', <<'__');
# Counts SLOC, whitespace, and total LOC in the codebase.
hook('before-loc', @_);

my $criteria    = join '|', @_;
my @attributes  = grep s/^sdoc:://, select_keys('--criteria' => $criteria);
my $tcomments   = 0;
my $twhitespace = 0;
my $tsource     = 0;

my $line = sub {
  my ($source, $whitespace, $comments, $name) = @_;
  $source ||= 1;                # Prevent divide-by-zero errors
  sprintf "%5d total, %4d SLOC, %5d[%4d%%] whitespace, %5d[%4d%%] comment [%s]",
          $source + $whitespace + $comments, $source, $whitespace, int($whitespace / $source * 100), $comments, int($comments / $source * 100), $name};

my $loc = sub {
  my @lines    = map split(/\n/, $_), retrieve($_[0]);
  $tcomments   += (my $comments   = grep /^\s*\/\// || /^\s*#/, @lines);
  $twhitespace += (my $whitespace = grep /^\s*$/, @lines);
  $tsource     += (my $source     = @lines - $comments - $whitespace);
  &$line($source, $whitespace, $comments, $_[0])};

terminal::info(map &$loc($_), @attributes);
terminal::info(&$line($tsource, $twhitespace, $tcomments, 'total'));

hook('after-loc', @_);
__
meta::function('lock', 'hook(\'lock\', chmod_self(sub {$_[0] & 0555}));');
meta::function('ls', <<'__');
my ($options, @criteria) = separate_options(@_);
my ($external, $shadows, $sizes, $flags, $long, $hashes, $parent_hashes) = @$options{qw(-e -s -z -f -l -h -p)};
$sizes = $flags = $hashes = $parent_hashes = 1 if $long;

return table_display([grep ! exists $data{$externalized_functions{$_}}, sort keys %externalized_functions]) if $shadows;

my $criteria    = join('|', @criteria);
my @definitions = select_keys('--criteria' => $criteria, %$options);

my %inverses  = map {$externalized_functions{$_} => $_} keys %externalized_functions;
my @externals = map $inverses{$_}, grep length, @definitions;
my @internals = grep length $inverses{$_}, @definitions;
my @sizes     = map sprintf('%6d %6d', length(serialize_single($_)), length(retrieve($_))), @{$external ? \@internals : \@definitions} if $sizes;

my @flags     = map {my $k = $_; join '', map(is($k, "-$_") ? $_ : '-', qw(d i m u))} @definitions if $flags;
my @hashes    = map fast_hash(retrieve($_)), @definitions if $hashes;

my %inherited     = parent_attributes(grep /^parent::/o, keys %data) if $parent_hashes;
my @parent_hashes = map $inherited{$_} || '-', @definitions if $parent_hashes;

join "\n", map strip($_), split /\n/, table_display($external ? [grep length, @externals] : [@definitions],
                                                    $sizes ? ([@sizes]) : (), $flags ? ([@flags]) : (), $hashes ? ([@hashes]) : (), $parent_hashes ? ([@parent_hashes]) : ());
__
meta::function('ls-a', 'ls(\'-ad\', @_);');
meta::function('mv', <<'__');
my ($from, $to) = @_;
die "'$from' does not exist" unless exists $data{$from};
associate($to, retrieve($from));
rm($from);
__
meta::function('name', <<'__');
my $name = $0;
$name =~ s/^.*\///;
$name;
__
meta::function('node', <<'__');
# Runs node on a collection of source files and arguments. The format is:
# node([@source_strings], @process_args);
my ($sources, @args) = @_;

with_exported(@$sources, sub {
  hook('before-node', $_[0], @args);
  sh('node', $_[0], @args);
  hook('after-node', $_[0], @args);
});
__
meta::function('node-custom', <<'__');
# Runs node on a collection of source files and arguments. The format is:
# &{'node-custom'}([@source_strings], [@node_arguments], @process_args);
my ($sources, $node_args, @args) = @_;

with_exported(@$sources, sub {
  hook('before-node-custom', @$node_args, $_[0], @args);
  sh('node', @$node_args, $_[0], @args);
  hook('after-node-custom', @$node_args, $_[0], @args);
});
__
meta::function('note', <<'__');
# Creates a note with a given name, useful for jotting things down.
create("note::$_[0]");
__
meta::function('notes', 'ls(\'-a\', \'^note::\');');
meta::function('parents', 'join "\\n", grep s/^parent:://o, sort keys %data;');
meta::function('perl', <<'__');
my $result = eval(join ' ', @_);
$@ ? terminal::error($@) : $result;
__
meta::function('preprocess', <<'__');
# Implements a simple preprocessing language.
# Syntax follows two forms. One is the 'line form', which gives you a way to specify arguments inline
# but not spanning multiple lines. The other is 'block form', which gives you access to both one-line
# arguments and a block of lines. The line parameters are passed in verbatim, and the block is
# indentation-adjusted and then passed in as a second parameter. (Indentation is adjusted to align
# with the name of the command.)
#
# Here are the forms:
#
# - line arguments to function
#
# - block line arguments << eof
#   block contents
#   block contents
#   ...
# - eof

my ($string, %options) = @_;
my $expansions         = 0;
my $old_string         = '';
my $limit              = $options{expansion_limit} || 100;
my @pieces             = ();

sub adjust_spaces {
  my ($spaces, $string) = @_;
  $string =~ s/^$spaces  //mg;
  chomp $string;
  $string;
}

while ($old_string ne $string and $expansions++ < $limit) {
  $old_string = $string;

  while ((my @pieces = split  /(^(\h*)-\h \S+ \h* \V* <<\h*(\w+)$ \n .*?  ^\2-\h\3$)/xms, $string) > 1 and $expansions++ < $limit) {
    $pieces[1 + ($_ << 2)] =~ /^ (\h*)-\h(\S+)\h*(\V*)<<\h*(\w+)$ \n(.*?) ^\1-\h\4 $/xms && $externalized_functions{"template::$2"} and
      $pieces[1 + ($_ << 2)] = &{"template::$2"}($3, adjust_spaces($1, $5))
      for 0 .. $#pieces / 4;

    @pieces[2 + ($_ << 2), 3 + ($_ << 2)] = '' for 0 .. $#pieces / 4;
    $string = join '', @pieces;
  }

  if ((my @pieces = split     /^(\h*-\h \S+ \h* .*)$/xom, $string) > 1) {
    $pieces[1 + ($_ << 1)] =~ /^ \h*-\h(\S+)\h*(.*)$/xom && $externalized_functions{"template::$1"} and
      $pieces[1 + ($_ << 1)] = &{"template::$1"}($2)
      for 0 .. $#pieces >> 1;

    $string = join '', @pieces;
  }
}

$string;
__
meta::function('reload', 'around_hook(\'reload\', sub {execute($_) for grep ! /^bootstrap::/, keys %data});');
meta::function('render', <<'__');
hook('before-render');
hook('after-render');
__
meta::function('rm', <<'__');
around_hook('rm', @_, sub {
  exists $data{$_} or terminal::warning("$_ does not exist") for @_;
  delete @data{@_}});
__
meta::function('run-forever', <<'__');
# Runs your application indefinitely, restarting each time it fails.
# There's a one-second delay between restarts to prevent a tight loop.
# Takes one argument, which is the function to run forever.
my ($f, @args) = @_;
hook('bin/before-run-forever');
&$f(@args) while sleep 0.1 && ! -f 'stop';
hook('bin/after-run-forever');
__
meta::function('save', 'around_hook(\'save\', sub {dangerous(\'\', sub {file::write($0, serialize()); $transient{initial} = state()}) if verify()});');
meta::function('save-state', <<'__');
# Creates a named copy of the current state and stores it.
my ($state_name) = @_;
around_hook('save-state', $state_name, sub {
  associate("state::$state_name", &{'current-state'}(), execute => 1)});
__
meta::function('sdoc', <<'__');
# Applies SDoc processing to a file or attribute. Takes the file or attribute
# name as the first argument and returns the processed text.

my %comments_for_extension = 
  qw|c     /*,*/  cpp   //    cc   //    h    //    java //  py  #    rb   #    pl  #   pm   #         ml   (*,*)  js  //
     hs    --     sh    #     lisp ;;;   lsp  ;;;   s    ;   scm ;;;  sc   ;;;  as  //  html <!--,-->  mli  (*,*)  cs  //
     vim   "      elisp ;     bas  '     ada  --    asm  ;   awk #    bc   #    boo #   tex  %         fss  (*,*)  erl %
     scala //     hx    //    io   //    j    NB.   lua  --  n   //   m    %    php //  sql  --        pov  //     pro %
     r     #      self  ","   tcl  #     texi @c    tk   #   csh #    vala //   vbs '   v    /*,*/     vhdl --     ss  ;;;
     haml  -#     sass  /*,*/ scss /*,*/ css  /*,*/ fig  /|;

# No extension suggests a shebang line, which generally requires # to denote a comment.
$comments_for_extension{''} = '#';

my $generated_string = 'Generated by SDoc';

sub is_code    {map /^\s*[^A-Z\|\s]/o, @_}
sub is_blank   {map /^\n/o, @_}
sub comment    {my ($text, $s, $e) = @_; join "\n", map("$s $_$e", split /\n/, $text)}

sub paragraphs {map split(/(\n{2,})/, $_), @_}

my ($filename) = @_;

# Two possibilities here. One is that the filename is an attribute, in which case
# we want to look up the extension in the transients table. The other is that
# it's a real filename.
my ($extension)       = $filename =~ /\.sdoc$/io ? $filename =~ /\.(\w+)\.sdoc$/igo : $filename =~ /\.(\w+)$/igo;
my ($other_extension) = extension_for(attribute($filename));
$other_extension =~ s/^\.//o;

my ($start, $end) = split /,/o, $comments_for_extension{lc($other_extension || $extension)};

join '', map(is_code($_) || is_blank($_) ? ($_ =~ /^\s*c\n(.*)$/so ? $1 : $_) : comment($_, $start, $end), paragraphs retrieve($filename)),
         "\n$start $generated_string $end\n";
__
meta::function('sdoc-html', <<'__');
# Converts SDoc to logically-structured HTML. Sections end up being nested,
# and code sections and examples are marked as such. For instance, here is some
# sample output:

# <div class='section level1'>
#   <h1 class='title'>Foo</h1>
#   <p>This is a paragraph...</p>
#   <p>This is another paragraph...</p>
#   <pre class='code'>int main () {return 0;}</pre>
#   <pre class='quoted'>int main () {return 0} // Won't compile</pre>
#   <div class='section level2'>
#     <h2 class='title'>Bar</h2>
#     ...
#   </div>
# </div>

# It is generally good about escaping things that would interfere with HTML,
# but within text paragraphs it lets you write literal HTML. The heuristic is
# that known tags that are reasonably well-formed are allowed, but unknown ones
# are escaped.

my ($attribute)   = @_;
my @paragraphs    = split /\n(?:\s*\n)+/, retrieve($attribute);

my $known_tags    = join '|', qw[html head body meta script style link title div a span input button textarea option select form label iframe blockquote code caption
                                 table tbody tr td th thead tfoot img h1 h2 h3 h4 h5 h6 li ol ul noscript p pre samp sub sup var canvas audio video];
my $section_level = 0;
my @markup;

my $indent        = sub {'  ' x ($_[0] || $section_level)};
my $unindent      = sub {my $spaces = '  ' x ($section_level - 1); s/^$spaces//gm};

my $escape_all    = sub {s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g};
my $escape_some   = sub {s/&/&amp;/g; s/<(?!\/|($known_tags)[^>]*>.*<\/\1>)/&lt;/gs};

my $code          = sub {&$escape_all(); &$unindent(); s/^c\n//;                   push @markup, &$indent() . "<pre class='code'>$_</pre>"};
my $quoted        = sub {&$escape_all(); &$unindent(); s/^\|(\s?)/ \1/; s/^  //mg; push @markup, &$indent() . "<pre class='quoted'>$_</pre>"};

my $paragraph     = sub {&$escape_some(); push @markup, &$indent() . "<p>$_</p>"};

my $section       = sub {my $h = $_[0] > 6 ? 6 : $_[0]; push @markup, &$indent($_[0] - 1) . "<div class='section level$_[0]'>", &$indent($_[0]) . "<h$h>$2</h$h>"};
my $close_section = sub {push @markup, &$indent($_[0]) . "</div>"};

my $title = sub {
  my $indentation = (length($1) >> 1) + 1;
  &$close_section($section_level) while $section_level-- >= $indentation;
  &$section($indentation);
  $section_level = $indentation;
};

for (@paragraphs) {
  &$code(),   next unless /^\h*[A-Z|]/;
  &$quoted(), next if     /^\h*\|/;

  &$title(), s/^.*\n// if /^(\s*)(\S.*)\.\n([^\n]+)/ and length("$1$2") - 10 < length($3);
  &$paragraph();
}

&$close_section($section_level) while $section_level--;

join "\n", @markup;
__
meta::function('sdocp', <<'__');
# Renders an attribute as SDocP. This logic was taken directly from the sdoc script.
my $attribute = retrieve($_[0]);
sub escape {my @results = map {s/\\/\\\\/go; s/\n/\\n/go; s/'/\\'/go; $_} @_; wantarray ? @results : $results[0]}
"sdocp('" . escape($_[0]) . "', '" . escape($attribute) . "');";
__
meta::function('serialize', <<'__');
my ($options, @criteria) = separate_options(@_);
my $partial     = $$options{'-p'};
my $criteria    = join '|', @criteria;
my @attributes  = map serialize_single($_), select_keys(%$options, '-m' => 1, '--criteria' => $criteria), select_keys(%$options, '-M' => 1, '--criteria' => $criteria);
my @final_array = @{$partial ? \@attributes : [retrieve('bootstrap::initialization'), @attributes, 'internal::main();', '', '__END__']};
join "\n", @final_array;
__
meta::function('serialize_single', <<'__');
# Serializes a single attribute and optimizes for content.

my $name          = $_[0] || $_;
my $contents      = $data{$name};
my $meta_function = 'meta::' . namespace($name);
my $invocation    = attribute($name);
my $escaped       = $contents;
$escaped =~ s/\\/\\\\/go;
$escaped =~ s/'/\\'/go;

return "$meta_function('$invocation', '$escaped');" unless $escaped =~ /\v/;

my $delimiter = '__' . fast_hash($contents);
my $chars     = 2;

++$chars until $chars >= length($delimiter) || index("\n$contents", "\n" . substr($delimiter, 0, $chars)) == -1;
$delimiter = substr($delimiter, 0, $chars);

"$meta_function('$invocation', <<'$delimiter');\n$contents\n$delimiter";
__
meta::function('sh', 'system(@_);');
meta::function('shell', <<'__');
terminal::cc(retrieve('data::current-continuation')) if length $data{'data::current-continuation'};
shell::repl();
__
meta::function('size', <<'__');
my $size = 0;
$size += length $data{$_} for keys %data;
sprintf "% 7d % 7d", length(serialize()), $size;
__
meta::function('snapshot', <<'__');
my ($name) = @_;
file::write(my $finalname = temporary_name($name), serialize(), noclobber => 1);
chmod 0700, $finalname;
hook('snapshot', $finalname);
__
meta::function('state', <<'__');
my @keys = sort keys %data;
my $hash = fast_hash(fast_hash(scalar @keys) . join '|', @keys);
$hash = fast_hash("$data{$_}|$hash") for @keys;
$hash;
__
meta::function('touch', 'associate($_, \'\') for @_;');
meta::function('unlock', 'hook(\'unlock\', chmod_self(sub {$_[0] | 0200}));');
meta::function('update', '&{\'update-from\'}(@_, grep s/^parent:://o, sort keys %data);');
meta::function('update-from', <<'__');
# Upgrade all attributes that aren't customized. Customization is defined when the data type is created,
# and we determine it here by checking for $transient{inherit}{$type}.

# Note that this assumes you trust the remote script. If you don't, then you shouldn't update from it.

around_hook('update-from-invocation', separate_options(@_), sub {
  my ($options, @targets) = @_;
  my %parent_id_cache = cache('parent-identification');
  my %already_seen;

  @targets or return;

  my @known_targets     = grep s/^parent:://, parent_ordering(map "parent::$_", grep exists $data{"parent::$_"}, @targets);
  my @unknown_targets   = grep ! exists $data{"parent::$_"}, @targets;
  @targets = (@known_targets, @unknown_targets);

  my $save_state        = ! ($$options{'-n'} || $$options{'--no-save'});
  my $no_parents        =    $$options{'-P'} || $$options{'--no-parent'} || $$options{'--no-parents'};
  my $force             =    $$options{'-f'} || $$options{'--force'};
  my $clobber_divergent =    $$options{'-D'} || $$options{'--clobber-divergent'};

  &{'save-state'}('before-update') if $save_state;

  for my $target (@targets) {
    dangerous("updating from $target", sub {
    around_hook('update-from', $target, sub {
      my $identity = $parent_id_cache{$target} ||= join '', qx($target identity);
      next if $already_seen{$identity};
      $already_seen{$identity} = 1;

      my $attributes = join '', qx($target ls -ahiu);
      my %divergent;
      die "skipping unreachable $target" unless $attributes;

      for my $to_rm (split /\n/, retrieve("parent::$target")) {
        my ($name, $hash) = split(/\s+/, $to_rm);
        next unless exists $data{$name};

        my $local_hash = fast_hash(retrieve($name));
        if ($clobber_divergent or $hash eq $local_hash or ! defined $hash) {rm($name)}
        else {terminal::info("preserving local version of divergent attribute $name (use update -D to clobber it)");
              $divergent{$name} = retrieve($name)}}

      associate("parent::$target", $attributes) unless $no_parents;

      dangerous('', sub {eval qx($target serialize -ipmu)});
      dangerous('', sub {eval qx($target serialize -ipMu)});

      map associate($_, $divergent{$_}), keys %divergent unless $clobber_divergent;

      reload()})})}

  cache('parent-identification', %parent_id_cache);

  if (verify()) {hook('update-from-succeeded', $options, @targets);
                 terminal::info("Successfully updated. Run 'load-state before-update' to undo this change.") if $save_state}
  elsif ($force) {hook('update-from-failed', $options, @targets);
                  terminal::warning('Failed to verify: at this point your object will not save properly, though backup copies will be created.',
                                    'Run "load-state before-update" to undo the update and return to a working state.') if $save_state}
  else {hook('update-from-failed', $options, @targets);
        terminal::error('Verification failed after the upgrade was complete.');
        terminal::info("$0 has been reverted to its pre-upgrade state.", "If you want to upgrade and keep the failure state, then run 'update-from $target --force'.") if $save_state;
        return &{'load-state'}('before-update') if $save_state}});
__
meta::function('usage', '"Usage: $0 action [arguments]\\nUnique actions (run \'$0 ls\' to see all actions):" . ls(\'-u\');');
meta::function('verify', <<'__');
file::write(my $other = $transient{temporary_filename} = temporary_name(), my $serialized_data = serialize());
chomp(my $observed = join '', qx|perl '$other' state|);

unlink $other if my $result = $observed eq (my $state = state());
terminal::error("Verification failed; expected $state but got $observed from $other") unless $result;
hook('after-verify', $result, observed => $observed, expected => $state);
$result;
__
meta::hook('after-render::base-files', 'file::write("$_.js", retrieve("js::$_")) for grep s/^sdoc::js:://, keys %data;');
meta::internal_function('around_hook', <<'__');
# around_hook('hookname', @args, sub {
#   stuff;
# });

# Invokes 'before-hookname' on @args before the sub runs, invokes the
# sub on @args, then invokes 'after-hookname' on @args afterwards.
# The after-hook is not invoked if the sub calls 'die' or otherwise
# unwinds the stack.

my $hook = shift @_;
my $f    = pop @_;

hook("before-$hook", @_);
my $result = &$f(@_);
hook("after-$hook", @_);
$result;
__
meta::internal_function('associate', <<'__');
my ($name, $value, %options) = @_;
die "Namespace does not exist" unless exists $datatypes{namespace($name)};
$data{$name} = $value;
execute($name) if $options{'execute'};
$value;
__
meta::internal_function('attribute', <<'__');
my ($name) = @_;
$name =~ s/^[^:]*:://;
$name;
__
meta::internal_function('attribute_is', <<'__');
my ($a, %options) = @_;
my %inherited     = parent_attributes(grep /^parent::/o, sort keys %data) if grep exists $options{$_}, qw/-u -U -d -D/;
my $criteria      = $options{'--criteria'} || $options{'--namespace'} && "^$options{'--namespace'}::" || '.';

my %tests = ('-u' => sub {! $inherited{$a}},
             '-d' => sub {$inherited{$a} && fast_hash(retrieve($a)) ne $inherited{$a}},
             '-i' => sub {$transient{inherit}{namespace($a)}},
             '-s' => sub {$a =~ /^state::/o},
             '-m' => sub {$a =~ /^meta::/o});

return 0 unless scalar keys %tests == scalar grep ! exists $options{$_}    ||   &{$tests{$_}}(), keys %tests;
return 0 unless scalar keys %tests == scalar grep ! exists $options{uc $_} || ! &{$tests{$_}}(), keys %tests;
$a =~ /$criteria/
__
meta::internal_function('cache', <<'__');
my ($name, %pairs) = @_;
if (%pairs) {associate("cache::$name", join "\n", map {$pairs{$_} =~ s/\n//g; "$_ $pairs{$_}"} sort keys %pairs)}
else        {map split(/\s/, $_, 2), split /\n/, retrieve("cache::$name")}
__
meta::internal_function('chmod_self', <<'__');
my ($mode_function)      = @_;
my (undef, undef, $mode) = stat $0;
chmod &$mode_function($mode), $0;
__
meta::internal_function('complete', <<'__');
my @functions  = sort keys %externalized_functions;
my @attributes = sort keys %data;

sub match {
  my ($text, @options) = @_;
  my @matches = sort grep /^$text/, @options;

  if    (@matches == 0) {return undef;}
  elsif (@matches == 1) {return $matches [0];}
  elsif (@matches >  1) {return ((longest ($matches [0], $matches [@matches - 1])), @matches);}
}

sub longest {
  my ($s1, $s2) = @_; 
  return substr ($s1, 0, length $1) if ($s1 ^ $s2) =~ /^(\0*)/;
  return ''; 
}

# This is another way to implement autocompletion.
#
# my $attribs = $term->Attribs;
# $attribs->{completion_entry_function} = $attribs->{list_completion_function};
# $attribs->{completion_word} = [sort keys %data, sort keys %externalized_functions];

my ($text, $line) = @_;
if ($line =~ / /) {
  # Start matching attribute names.
  match ($text, @attributes);
} else {
  # Start of line, so it's a function.
  match ($text, @functions);
}
__
meta::internal_function('dangerous', <<'__');
# Wraps a computation that may produce an error.
my ($message, $computation) = @_;
terminal::info($message) if $message;
my @result = eval {&$computation()};
terminal::warning(translate_backtrace($@)), return undef if $@;
wantarray ? @result : $result[0];
__
meta::internal_function('debug_trace', <<'__');
terminal::debug(join ', ', @_);
wantarray ? @_ : $_[0];
__
meta::internal_function('dep', <<'__');
# A variadic function to prepend cached_dependency:: onto things.
# Used like this: dep(qw/caterwaul.all.js montenegro.server.js/)
map "cached_dependency::$_", @_;
__
meta::internal_function('execute', <<'__');
my ($name, %options) = @_;
my $namespace = namespace($name);
eval {&{"meta::$namespace"}(attribute($name), retrieve($name))};
warn $@ if $@ && $options{'carp'};
__
meta::internal_function('exported', <<'__');
# Allocates a temporary file containing the concatenation of attributes you specify,
# and returns the filename. The filename will be safe for deletion anytime.
my $filename = temporary_name();
file::write($filename, cat(@_));
$filename;
__
meta::internal_function('extension_for', <<'__');
my $extension = $transient{extension}{namespace($_[0])};
$extension = &$extension($_[0]) if ref $extension eq 'CODE';
$extension || '';
__
meta::internal_function('fast_hash', <<'__');
my ($data)     = @_;
my $piece_size = length($data) >> 3;

my @pieces     = (substr($data, $piece_size * 8) . length($data), map(substr($data, $piece_size * $_, $piece_size), 0 .. 7));
my @hashes     = (fnv_hash($pieces[0]));

push @hashes, fnv_hash($pieces[$_ + 1] . $hashes[$_]) for 0 .. 7;

$hashes[$_] ^= $hashes[$_ + 4] >> 16 | ($hashes[$_ + 4] & 0xffff) << 16 for 0 .. 3;
$hashes[0]  ^= $hashes[8];

sprintf '%08x' x 4, @hashes[0 .. 3];
__
meta::internal_function('file::read', <<'__');
my $name = shift;
open my($handle), "<", $name;
my $result = join "", <$handle>;
close $handle;
$result;
__
meta::internal_function('file::write', <<'__');
use File::Path     'mkpath';
use File::Basename 'dirname';

my ($name, $contents, %options) = @_;
die "Choosing not to overwrite file $name" if $options{noclobber} and -f $name;
mkpath(dirname($name)) if $options{mkpath};

open my($handle), $options{append} ? '>>' : '>', $name or die "Can't open $name for writing";
print $handle $contents;
close $handle;
__
meta::internal_function('fnv_hash', <<'__');
# A rough approximation to the Fowler-No Voll hash. It's been 32-bit vectorized
# for efficiency, which may compromise its effectiveness for short strings.

my ($data) = @_;

my ($fnv_prime, $fnv_offset) = (16777619, 2166136261);
my $hash                     = $fnv_offset;
my $modulus                  = 2 ** 32;

$hash = ($hash ^ ($_ & 0xffff) ^ ($_ >> 16)) * $fnv_prime % $modulus for unpack 'L*', $data . substr($data, -4) x 8;
$hash;
__
meta::internal_function('hypothetically', <<'__');
# Applies a temporary state and returns a serialized representation.
# The original state is restored after this, regardless of whether the
# temporary state was successful.

my %data_backup   = %data;
my ($side_effect) = @_;
my $return_value  = eval {&$side_effect()};
%data = %data_backup;

die $@ if $@;
$return_value;
__
meta::internal_function('internal::main', <<'__');
disable();

$SIG{'INT'} = sub {snapshot(); exit 1};

$transient{initial}      = state();
chomp(my $default_action = retrieve('data::default-action'));

my $function_name = shift(@ARGV) || $default_action || 'usage';
terminal::warning("unknown action: '$function_name'") and $function_name = 'usage' unless $externalized_functions{$function_name};

around_hook('main-function', $function_name, @ARGV, sub {
  dangerous('', sub {
    chomp(my $result = &$function_name(@ARGV));
    print "$result\n" if $result})});

save() unless state() eq $transient{initial};

END {
  enable();
}
__
meta::internal_function('invoke_editor_on', <<'__');
my ($data, %options) = @_;
my $editor    = $options{editor} || $ENV{VISUAL} || $ENV{EDITOR} || die 'Either the $VISUAL or $EDITOR environment variable should be set to a valid editor';
my $options   = $options{options} || $ENV{VISUAL_OPTS} || $ENV{EDITOR_OPTS} || '';
my $attribute = $options{attribute};
$attribute =~ s/\//-/g;
my $filename  = temporary_name() . "-$attribute$options{extension}";

file::write($filename, $data);
system("$editor $options '$filename'");

my $result = file::read($filename);
unlink $filename;
$result;
__
meta::internal_function('is_locked', '!((stat($0))[2] & 0222);');
meta::internal_function('namespace', <<'__');
my ($name) = @_;
$name =~ s/::.*$//;
$name;
__
meta::internal_function('parent_attributes', <<'__');
my $attributes = sub {my ($name, $value) = split /\s+/o, $_; $name => ($value || 1)};
map &$attributes(), split /\n/o, join("\n", retrieve(@_));
__
meta::internal_function('parent_ordering', <<'__');
# Topsorts the parents by dependency chain. The simplest way to do this is to
# transitively compute the number of parents referred to by each parent.

my @parents = @_;
my %all_parents = map {$_ => 1} @parents;

my %parents_of = map {
  my $t = $_;
  my %attributes = parent_attributes($_);
  $t => [grep /^parent::/, keys %attributes]} @parents;

my %parent_count;
my $parent_count;
$parent_count = sub {
  my ($key) = @_;
  return $parent_count{$key} if exists $parent_count{$key};
  my $count = 0;
  $count += $parent_count->($_) + exists $data{$_} for @{$parents_of{$key}};
  $parent_count{$key} = $count};

my %inverses;
push @{$inverses{$parent_count->($_)} ||= []}, $_ for @parents;
grep exists $all_parents{$_}, map @{$inverses{$_}}, sort keys %inverses;
__
meta::internal_function('retrieve', <<'__');
my @results = map defined $data{$_} ? $data{$_} : retrieve_with_hooks($_), @_;
wantarray ? @results : $results[0];
__
meta::internal_function('retrieve_with_hooks', <<'__');
# Uses the hooks defined in $transient{retrievers}, and returns undef if none work.
my ($attribute) = @_;
my $result      = undef;

defined($result = &$_($attribute)) and return $result for map $transient{retrievers}{$_}, sort keys %{$transient{retrievers}};
return undef;
__
meta::internal_function('select_keys', <<'__');
my %options = @_;
grep attribute_is($_, %options), sort keys %data;
__
meta::internal_function('separate_options', <<'__');
# Things with one dash are short-form options, two dashes are long-form.
# Characters after short-form are combined; so -auv4 becomes -a -u -v -4.
# Also finds equivalences; so --foo=bar separates into $$options{'--foo'} eq 'bar'.
# Stops processing at the -- option, and removes it. Everything after that
# is considered to be an 'other' argument.

# The only form not supported by this function is the short-form with argument.
# To pass keyed arguments, you need to use long-form options.

my @parseable;
push @parseable, shift @_ until ! @_ or $_[0] eq '--';

my @singles = grep /^-[^-]/, @parseable;
my @longs   = grep /^--/,    @parseable;
my @others  = grep ! /^-/,   @parseable;

my @singles = map /-(.{2,})/ ? map("-$_", split(//, $1)) : $_, @singles;

my %options;
  $options{$1} = $2 for grep /^([^=]+)=(.*)$/, @longs;
++$options{$_}      for grep ! /=/, @singles, @longs;

({%options}, @others, @_);
__
meta::internal_function('strip', 'wantarray ? map {s/^\\s*|\\s*$//g; $_} @_ : $_[0] =~ /^\\s*(.*?)\\s*$/ && $1;');
meta::internal_function('table_display', <<'__');
# Displays an array of arrays as a table; that is, with alignment. Arrays are
# expected to be in column-major order.

sub maximum_length_in {
  my $maximum = 0;
  length > $maximum and $maximum = length for @_;
  $maximum;
}

my @arrays    = @_;
my @lengths   = map maximum_length_in(@$_), @arrays;
my @row_major = map {my $i = $_; [map $$_[$i], @arrays]} 0 .. $#{$arrays[0]};
my $format    = join '  ', map "%-${_}s", @lengths;

join "\n", map strip(sprintf($format, @$_)), @row_major;
__
meta::internal_function('temporary_name', <<'__');
use File::Temp 'tempfile';
my (undef, $temporary_filename) = tempfile("$0." . 'X' x 4, OPEN => 0);
$temporary_filename;
__
meta::internal_function('translate_backtrace', <<'__');
my ($trace) = @_;
$trace =~ s/\(eval (\d+)\)/$locations{$1 - 1}/g;
$trace;
__
meta::internal_function('with_exported', <<'__');
# Like exported(), but removes the file after running some function.
# Usage is with_exported(@files, sub {...});
my $f      = pop @_;
my $name   = exported(@_);
my $result = eval {&$f($name)};
terminal::warning("$@ when running with_exported()") if $@;
unlink $name;
$result;
__
meta::library('shell', <<'__');
# Functions for shell parsing and execution.
package shell;
use Term::ReadLine;

sub tokenize {grep length, split /\s+|("[^"\\]*(?:\\.)?")/o, join ' ', @_};

sub parse {
  my ($fn, @args) = @_;
  s/^"(.*)"$/\1/o, s/\\\\"/"/go for @args;
  {function => $fn, args => [@args]}}

sub execute {
  my %command = %{$_[0]};
  die "undefined command: $command{function}" unless exists $externalized_functions{$command{function}};
  &{"::$command{function}"}(@{$command{args}})}

sub run {execute(parse(tokenize(@_)))}

sub prompt {
  my %options = @_;
  my $name    = $options{name}  // ::name();
  my $state   = $options{state} // ::state();
  my $other   = $state ne $transient{initial} ? 33 : 30;
  my $locked  = ::is_locked() ? "\033[1;31mlocked\033[0;0m" : '';
  my $cc      = length ::retrieve('data::current-continuation') ? "\033[1;36mcc\033[0;0m" : '';

  "\033[1;32m$name\033[1;${other}m" . substr($state, 0, 4) . "\033[0;0m$cc$locked\033[1;34m$options{stuff}\033[0;0m "}

sub repl {
  my %options = @_;

  my $term = new Term::ReadLine "$0 shell";
  $term->ornaments(0);
  my $attribs = $term->Attribs;
  $attribs->{completion_entry_function} = $attribs->{list_completion_function};

  my $autocomplete = $options{autocomplete} || sub {[sort keys %data, sort keys %externalized_functions]};
  my $prompt       = $options{prompt}       || \&prompt;
  my $parse        = $options{parse}        || sub {parse(tokenize(@_))};
  my $command      = $options{command}      || sub {my ($command) = @_; ::around_hook('shell-command', $command, sub {print ::dangerous('', sub {execute($command)}), "\n"})};

  &$command(&$parse($_)) while ($attribs->{completion_word} = &$autocomplete(), defined($_ = $term->readline(&$prompt())))}
__
meta::library('terminal', <<'__');
# Functions for nice-looking terminal output.
package terminal;

my $process = ::name();

sub message {print STDERR "[$_[0]] $_[1]\n"}
sub color {
  my ($name, $color) = @_;
  *{"terminal::$name"} = sub {chomp($_), print STDERR "\033[1;30m$process(\033[1;${color}m$name\033[1;30m)\033[0;0m $_\n" for map join('', $_), @_}}

my %preloaded = (info => 32, progress => 32, state => 34, debug => 34, warning => 33, error => 31);
color $_, $preloaded{$_} for keys %preloaded;
__
meta::message_color('cc', '36');
meta::message_color('state', 'purple');
meta::message_color('states', 'yellow');
meta::message_color('test', 'purple');
meta::message_color('watch', 'blue');
meta::parent('/home/spencertipping/bin/configuration', <<'__');
meta::type::configuration                d67e10a128e6b1d958c5b9d3bbe25aa4
parent::/home/spencertipping/bin/object  9088a9cf9c95b7c1184f1c3b528824ba
__
meta::parent('/home/spencertipping/bin/node-base', <<'__');
function::loc                                               36e0cabf1fe1c1bcaa3c8c708bd82ca0
function::node                                              3522fde8f76947a5f70bca33f1ee0016
function::node-custom                                       c2f4063798c997ec7f78a3543b1240b3
function::render                                            4962b4a2e6bc800fd5c11b97550b623e
function::run-forever                                       76175932a2d2692fc802856c28d0848d
internal_function::dep                                      bad9b934374b176318ed2295b63130bc
message_color::test                                         14e993fdf2c62df353613c243dc9053b
meta::type::js                                              f7a0080116fecebf7abb030b0156f44d
parent::/home/spencertipping/bin/repository                 0d317b0c917f59703ee01bf3cf03ad13
parent::/home/spencertipping/conjectures/perl-objects/sdoc  7123644754d371e203fe3cb97af02af4
parent::notes                                               d70bf6eb1e4108e29a132c399e599c66
parent::preprocessor                                        30aa7c5087c842a5eaf3ddccd9b5046f
__
meta::parent('/home/spencertipping/bin/object', <<'__');
bootstrap::html                         9b839f4c0c8d6bb18bf6d9d0e670e497
bootstrap::initialization               b39f25c213ceb0418551084d1bddeb20
bootstrap::perldoc                      c63395cbc6f7160b603befbb2d9b6700
function::alias                         28744564997657da45ab16cd5b441104
function::cat                           a19fdfda461f9a0aa01978dff2e2c2f7
function::cc                            c4d52b1d8f52a480f07b81b93c3aac7b
function::ccc                           2351344fc688518c75aa4ab3acec1c4a
function::child                         f69646398c3123d3d939a7f2b3156606
function::clone                         54e00ff2103e54423d4c9febb97ce063
function::cp                            e5fee448a74ecbf4ae215e6b43dfc048
function::create                        090c342a2dc304b39c643d53350474a0
function::current-state                 48c98d3bd74f3ee14d358fd127a7867a
function::disable                       49db26fcd680ca34c1f52629a7375d2f
function::edit                          c31d73791820a10ec910af043f67d4eb
function::enable                        37af2d2e603e2455be227ae3c5a42c3a
function::export                        388e0cc60507443cb1c0cc3e2658cfef
function::extern                        6a9fa8c2a8a4eaae9fe8d38e402145e4
function::grep                          3ad630ca30f1abae3cf28ef6293f0e00
function::hash                          7a903f90f2c8ed27af7e030f407d9f7b
function::hook                          d74d8e2b611342af6a0897e0bd62e6e6
function::hooks                         230122bdc8929884e45b2f78a7743e2e
function::identity                      37106ce13a0200af001d361ce7e81e57
function::import                        ac86cbe9c9fb12fc8cef2cc88e80c01e
function::initial-state                 e21ba3519838b221a7b2d4e8a7544e7f
function::is                            1d3401965e4720ed972470b54b447db0
function::load-state                    ea18db867bd62a294e067f60e6975dcf
function::lock                          9bf21fee2f0f809131d43553bde82fa5
function::ls                            61a247f0a582f63d85b5d5a963a46893
function::mv                            52e95180e3c7019116bd798e0da0fdda
function::name                          6848cbc257e4b6d7441b25acb04e23c9
function::parents                       f94c3a5addbc92fe7f90d198fa701484
function::perl                          986a274c013b77fe08d29726ce3799fe
function::reload                        c57ff432c3ffd91a5506cd3eb8bf50c9
function::rm                            7cecfb1691a7bf86741f00058bcc54ca
function::save                          181da4858ac39c157dbf38e6bac7a0d2
function::save-state                    863e4d9fa75ca198ef7a755248d1002a
function::serialize                     5148e8ca46eeb3e297f76d098e496bcf
function::serialize_single              e7a22f806b580d5c63982ffc7f218a1a
function::sh                            9647fa9227bef6c139a79d0dd4acc8b4
function::shell                         dc8238ad70b1e02eaf230c4f1bd21690
function::size                          140728e163286a0f3f514f468c475cfc
function::snapshot                      d3d84a364524eeb8ee90623f545187e8
function::state                         119111f84c3e32a5536838ac84bc6f10
function::touch                         819878bc64df094d3323c7050f2c3e97
function::unlock                        8fc9bd69f3466f0b54ee2c6965f68cea
function::update                        4de1a6a4085836590a3b1ef997f9d5ea
function::update-from                   beead29d50b0b204bc9a8dc6f07d0003
function::usage                         b36ead828ad566c8e3919f3b40fb99e6
function::verify                        d31b85fffd464ddf516d2afeb63dcbde
internal_function::around_hook          e1cd17b80d4e8165df9c94facd9f239b
internal_function::associate            fc4f785bcf3ffe3225a73a1fdd314703
internal_function::attribute            62efb9f22157835940af1d5feae98d98
internal_function::attribute_is         c88e0f87cf807ab0af73ca10032b54b2
internal_function::cache                c119f9d7ea9a147c6d526a6283fb119a
internal_function::chmod_self           b13487447c65f2dc790bd6b21dde89dd
internal_function::dangerous            4b8343178d6d4d1b760d61b1cfda008c
internal_function::debug_trace          77644ab45a770a6e172680f659911507
internal_function::execute              4b4efc33bc6767a7aade7f427eedf83f
internal_function::exported             27414e8f2ceeaef3555b9726e690eb0f
internal_function::extension_for        65e48f50f20bc04aa561720b03bf494c
internal_function::fast_hash            ac70f469e697725cfb87629833434ab1
internal_function::file::read           186bbcef8f6f0dd8b72ba0fdeb1de040
internal_function::file::write          eb7b1efebe0db73378b0cce46681788d
internal_function::fnv_hash             8d001a3a7988631bab21a41cee559758
internal_function::hypothetically       33ee2e1595d3877bd1d9accaa72305c8
internal_function::internal::main       435a9e83ac803960745d9aa5aac6c75f
internal_function::invoke_editor_on     1448132d5294a4b8390b4a684d8a78f9
internal_function::is_locked            42c3c89625863a31105d1df49a2a762f
internal_function::namespace            93213d60cafb9627e0736b48cd1f0760
internal_function::parent_attributes    480776f176ab728c6b7450287be5782a
internal_function::parent_ordering      87bee77390de5b9e9c6e07f9af9eb70a
internal_function::retrieve             0b6f4342009684fdfa259f45ac75ae37
internal_function::retrieve_with_hooks  5186a0343624789d08d1cc2084550f3d
internal_function::select_keys          1cd075b241905d9ab3199e680e86dced
internal_function::separate_options     d47e8ee23fe55e27bb523c9fcb2f5ca1
internal_function::strip                4af6a470effeed94c0dd9800d01f7d66
internal_function::table_display        8a6897e093f36bf05477a3889b84a61d
internal_function::temporary_name       0fb1402061581b69822f913631b4a9d9
internal_function::translate_backtrace  06fad3d85833a6484e426401b95e0206
internal_function::with_exported        fc4f32c46d95c6deed0414364d1c7410
library::shell                          528f486cc4d9eb390e4c350b8727c751
library::terminal                       c52308d05ebb4ff61c5fc36e6d9c7a8a
message_color::cc                       6249446f73b3c5af2404c322c150e57b
message_color::state                    14e993fdf2c62df353613c243dc9053b
message_color::states                   152a940086f7cee6110528a09af7dd78
meta::configure                         25976e07665878d3fae18f050160343f
meta::externalize                       9141b4e8752515391385516ae94b23b5
meta::functor::editable                 e3d2ede6edf65ffe2123584b2bd5dab7
meta::type::alias                       28fe15dd61f4902ed5180d8604d15d97
meta::type::bootstrap                   297d03fb32df03b46ea418469fc4e49e
meta::type::cache                       52eac0d7b550a358cc86803fe1a9d921
meta::type::data                        58d8027f20099b28a159eaac67314051
meta::type::function                    d93b3cc15693707dac518e3d6b1f5648
meta::type::hook                        f55a3f728ddfb90204dff3fe5d86845c
meta::type::inc                         c95915391b969734305f2f492d5ca8e3
meta::type::internal_function           34abb44c67c7e282569e28ef6f4d62ab
meta::type::library                     b6dd78120e6d787acdb5c1629f7f1896
meta::type::message_color               794bf137c425293738f07636bcfb5c55
meta::type::meta                        640f25635ce2365b0648962918cf9932
meta::type::parent                      607e9931309b1b595424bedcee5dfa45
meta::type::retriever                   6e847a9d205e4a5589765a3366cdd115
meta::type::state                       c1f29670be26f1df6100ffe4334e1202
retriever::file                         b8e7aefc98b8341260d91f21dc61d749
retriever::id                           a791a5735e9b4f2cb8b99fd39dc17bc3
__
meta::parent('/home/spencertipping/bin/repository', <<'__');
function::dupdate                               1c0273217c5b9f2756bb14a4a00aa7e2
meta::type::cached_dependency                   e9455b403cbff27bbcc41d917fef482f
parent::/home/spencertipping/bin/configuration  e4d22dc2215115982f6b79ed0ce22a42
__
meta::parent('/home/spencertipping/conjectures/perl-objects/sdoc', <<'__');
function::sdoc                           060cfa349e629eb90a82b87a8ba00c1d
function::sdoc-html                      4ec4c1710abddb753db5557d79e6b165
function::sdocp                          8b7ed5bbd537234ae53c0691b6d02c97
meta::type::sdoc                         392c65eddae300e2aa67014b85884979
parent::/home/spencertipping/bin/object  9088a9cf9c95b7c1184f1c3b528824ba
retriever::html-sdoc                     54d22ab83d9f3f2e27ef51033b4817a7
retriever::sdoc                          6de8ec1f1436fb8e7477b533c321081b
retriever::sdocp                         fef74cd94fa8761618662802f0bfc171
__
meta::parent('notes', <<'__');
function::note    bcbfeac6dd2112f47296265444570a6e
function::notes   15b3aca0cba3b327a984928154eda2b5
meta::type::note  7ca6b375a66ecbfd14bef5bcefeb6643
parent::object    9088a9cf9c95b7c1184f1c3b528824ba
__
meta::parent('object', <<'__');
bootstrap::html                         9b839f4c0c8d6bb18bf6d9d0e670e497
bootstrap::initialization               b39f25c213ceb0418551084d1bddeb20
bootstrap::perldoc                      c63395cbc6f7160b603befbb2d9b6700
function::alias                         28744564997657da45ab16cd5b441104
function::cat                           a19fdfda461f9a0aa01978dff2e2c2f7
function::cc                            c4d52b1d8f52a480f07b81b93c3aac7b
function::ccc                           2351344fc688518c75aa4ab3acec1c4a
function::child                         f69646398c3123d3d939a7f2b3156606
function::clone                         54e00ff2103e54423d4c9febb97ce063
function::cp                            e5fee448a74ecbf4ae215e6b43dfc048
function::create                        090c342a2dc304b39c643d53350474a0
function::current-state                 48c98d3bd74f3ee14d358fd127a7867a
function::disable                       49db26fcd680ca34c1f52629a7375d2f
function::edit                          c31d73791820a10ec910af043f67d4eb
function::enable                        37af2d2e603e2455be227ae3c5a42c3a
function::export                        388e0cc60507443cb1c0cc3e2658cfef
function::extern                        6a9fa8c2a8a4eaae9fe8d38e402145e4
function::grep                          3ad630ca30f1abae3cf28ef6293f0e00
function::hash                          7a903f90f2c8ed27af7e030f407d9f7b
function::hook                          d74d8e2b611342af6a0897e0bd62e6e6
function::hooks                         230122bdc8929884e45b2f78a7743e2e
function::identity                      37106ce13a0200af001d361ce7e81e57
function::import                        ac86cbe9c9fb12fc8cef2cc88e80c01e
function::initial-state                 e21ba3519838b221a7b2d4e8a7544e7f
function::is                            1d3401965e4720ed972470b54b447db0
function::load-state                    ea18db867bd62a294e067f60e6975dcf
function::lock                          9bf21fee2f0f809131d43553bde82fa5
function::ls                            61a247f0a582f63d85b5d5a963a46893
function::mv                            52e95180e3c7019116bd798e0da0fdda
function::name                          6848cbc257e4b6d7441b25acb04e23c9
function::parents                       f94c3a5addbc92fe7f90d198fa701484
function::perl                          986a274c013b77fe08d29726ce3799fe
function::reload                        c57ff432c3ffd91a5506cd3eb8bf50c9
function::rm                            7cecfb1691a7bf86741f00058bcc54ca
function::save                          181da4858ac39c157dbf38e6bac7a0d2
function::save-state                    863e4d9fa75ca198ef7a755248d1002a
function::serialize                     5148e8ca46eeb3e297f76d098e496bcf
function::serialize_single              e7a22f806b580d5c63982ffc7f218a1a
function::sh                            9647fa9227bef6c139a79d0dd4acc8b4
function::shell                         dc8238ad70b1e02eaf230c4f1bd21690
function::size                          140728e163286a0f3f514f468c475cfc
function::snapshot                      d3d84a364524eeb8ee90623f545187e8
function::state                         119111f84c3e32a5536838ac84bc6f10
function::touch                         819878bc64df094d3323c7050f2c3e97
function::unlock                        8fc9bd69f3466f0b54ee2c6965f68cea
function::update                        4de1a6a4085836590a3b1ef997f9d5ea
function::update-from                   beead29d50b0b204bc9a8dc6f07d0003
function::usage                         b36ead828ad566c8e3919f3b40fb99e6
function::verify                        d31b85fffd464ddf516d2afeb63dcbde
internal_function::around_hook          e1cd17b80d4e8165df9c94facd9f239b
internal_function::associate            fc4f785bcf3ffe3225a73a1fdd314703
internal_function::attribute            62efb9f22157835940af1d5feae98d98
internal_function::attribute_is         c88e0f87cf807ab0af73ca10032b54b2
internal_function::cache                c119f9d7ea9a147c6d526a6283fb119a
internal_function::chmod_self           b13487447c65f2dc790bd6b21dde89dd
internal_function::dangerous            4b8343178d6d4d1b760d61b1cfda008c
internal_function::debug_trace          77644ab45a770a6e172680f659911507
internal_function::execute              4b4efc33bc6767a7aade7f427eedf83f
internal_function::exported             27414e8f2ceeaef3555b9726e690eb0f
internal_function::extension_for        65e48f50f20bc04aa561720b03bf494c
internal_function::fast_hash            ac70f469e697725cfb87629833434ab1
internal_function::file::read           186bbcef8f6f0dd8b72ba0fdeb1de040
internal_function::file::write          eb7b1efebe0db73378b0cce46681788d
internal_function::fnv_hash             8d001a3a7988631bab21a41cee559758
internal_function::hypothetically       33ee2e1595d3877bd1d9accaa72305c8
internal_function::internal::main       435a9e83ac803960745d9aa5aac6c75f
internal_function::invoke_editor_on     1448132d5294a4b8390b4a684d8a78f9
internal_function::is_locked            42c3c89625863a31105d1df49a2a762f
internal_function::namespace            93213d60cafb9627e0736b48cd1f0760
internal_function::parent_attributes    480776f176ab728c6b7450287be5782a
internal_function::parent_ordering      87bee77390de5b9e9c6e07f9af9eb70a
internal_function::retrieve             0b6f4342009684fdfa259f45ac75ae37
internal_function::retrieve_with_hooks  5186a0343624789d08d1cc2084550f3d
internal_function::select_keys          1cd075b241905d9ab3199e680e86dced
internal_function::separate_options     d47e8ee23fe55e27bb523c9fcb2f5ca1
internal_function::strip                4af6a470effeed94c0dd9800d01f7d66
internal_function::table_display        8a6897e093f36bf05477a3889b84a61d
internal_function::temporary_name       0fb1402061581b69822f913631b4a9d9
internal_function::translate_backtrace  06fad3d85833a6484e426401b95e0206
internal_function::with_exported        fc4f32c46d95c6deed0414364d1c7410
library::shell                          528f486cc4d9eb390e4c350b8727c751
library::terminal                       c52308d05ebb4ff61c5fc36e6d9c7a8a
message_color::cc                       6249446f73b3c5af2404c322c150e57b
message_color::state                    14e993fdf2c62df353613c243dc9053b
message_color::states                   152a940086f7cee6110528a09af7dd78
meta::configure                         25976e07665878d3fae18f050160343f
meta::externalize                       9141b4e8752515391385516ae94b23b5
meta::functor::editable                 e3d2ede6edf65ffe2123584b2bd5dab7
meta::type::alias                       28fe15dd61f4902ed5180d8604d15d97
meta::type::bootstrap                   297d03fb32df03b46ea418469fc4e49e
meta::type::cache                       52eac0d7b550a358cc86803fe1a9d921
meta::type::data                        58d8027f20099b28a159eaac67314051
meta::type::function                    d93b3cc15693707dac518e3d6b1f5648
meta::type::hook                        f55a3f728ddfb90204dff3fe5d86845c
meta::type::inc                         c95915391b969734305f2f492d5ca8e3
meta::type::internal_function           34abb44c67c7e282569e28ef6f4d62ab
meta::type::library                     b6dd78120e6d787acdb5c1629f7f1896
meta::type::message_color               794bf137c425293738f07636bcfb5c55
meta::type::meta                        640f25635ce2365b0648962918cf9932
meta::type::parent                      607e9931309b1b595424bedcee5dfa45
meta::type::retriever                   6e847a9d205e4a5589765a3366cdd115
meta::type::state                       c1f29670be26f1df6100ffe4334e1202
retriever::file                         b8e7aefc98b8341260d91f21dc61d749
retriever::id                           a791a5735e9b4f2cb8b99fd39dc17bc3
__
meta::parent('preprocessor', <<'__');
function::preprocess           66e539d29e9afa903569efad0eb7c886
meta::type::template           25f4d6eafb1d3eea6d5d3d9a71a5623e
parent::object                 9088a9cf9c95b7c1184f1c3b528824ba
retriever::pp                  f4a8c288d69963d6ebc5ce0bf7794777
template::comment              7f8e9be5cd7c865fa64efe3123f62b38
template::eval                 eb0b1058649eb2d833f348540516b358
template::failing_conditional  5c593329b434a7044f68cec4b77e8ed9
template::include              e0624844a65ae41e0217dd871fc0dbfb
template::pinclude             5ba61c3034a4b183881936aec30d2be9
__
meta::retriever('file', '-f $_[0] ? file::read($_[0]) : undef;');
meta::retriever('html-sdoc', <<'__');
my ($attribute) = @_;
return undef unless $attribute =~ s/^html::/sdoc::/ and exists $data{$attribute};
&{'sdoc-html'}($attribute);
__
meta::retriever('id', '$_[0] =~ /^id::/ ? substr($_[0], 4) : undef;');
meta::retriever('pp', <<'__');
return undef unless namespace($_[0]) eq 'pp';
my $attr = retrieve(attribute($_[0]));
defined $attr ? preprocess($attr) : undef;
__
meta::retriever('sdoc', 'exists $data{"sdoc::$_[0]"} ? sdoc("sdoc::$_[0]") : undef;');
meta::retriever('sdocp', <<'__');
my $attribute = attribute($_[0]);
exists $data{"sdoc::$attribute"} ? sdocp("sdoc::$attribute") : undef;
__
meta::sdoc('js::modus', <<'__');
Modus core combinators | Spencer Tipping
Licensed under the terms of the MIT source code license

Introduction.
Modus is a set of combinators that wrap jQuery objects and provides its own methods for type-specified DOM manipulation. It does this by letting you define method-sets that operate on given
sets of elements; these are installed on modus wrappers. Modus wrappers are to jQuery as jQuery is to the DOM; they cross-cut jQuery's selector "hierarchy" and provide a more coherent and
domain-specific set of functionality. Modus diverges from jQuery by specializing, rather than generalizing, the DOM.

  Example: parsed e-mail input box.
  Suppose you want to create a text box that accepts e-mail addresses and maps those addresses into their parsed username, domain name, and TLD. In regular jQuery with Caterwaul you might
  write this:

  | email_box(x) = jquery [input.email /instavalidate(/\w+@\w+\.\w+/) /val(x || '')]
                   -effect [it.data('parsed', given.nothing in parse_email(it.val()))];

  Then the usage works this way:

  | var parsed = something.find('.email').data('parsed')();

  The 'data' invocation is required to bind the function to the actual <input> node rather than to the jQuery selector that contains it (which is highly transient due to jQuery's design).
  Modus lets you write this instead:

  | email_box_behavior = modus().method('parsed', given.nothing in parse_email(this.jquery.val()));
    email_box(x) = email_box_behavior(jquery in input.email /instavalidate(/\w+@\w+\.\w+/) /val(x || ''));

  Modus provides a much more straightforward usage pattern:

  | var parsed = something.find(email_box_behavior).parsed();
    var parsed = something.find('.email').parsed();             // Equivalent, depending on component layout

  Example: composite component.
  This is the real case where jQuery isn't sufficient. Suppose you've got a heterogeneous composition of components and want to automatically propagate state both downwards and upwards. This
  requires some kind of abstraction, and modus gives you a way to express that:

  | person_behavior = modus().selector({name: 'td.name input', email: 'td.email input'}).
                              attr('val', given.nothing in {name: this.name().val(), email: this.email().val()},
                                          given.x       in this -effect- it.name().val(x.name)
                                                                -effect- it.email().val(x.email));
    person(p) = person_behavior(jquery in table.person(tr(td.name(input /val(p.name)), td.email[email_box(p.email)])));

  Widget combination is a really common thing to want to do, so modus provides higher-order behaviors to help. These higher-order behaviors build up the val() function and selectors for you so
  that you don't have to:

  | person_behavior = modus.composite({name: 'td.name input', email: 'td.email input'});
    person(p)       = person_behavior(jquery in table.person(tr(td.name(input), td.email[email_box()]))).val(p);

  Here's what usage looks like:

  | my_person = person({name: 'bob', email: 'woot@woot.com'});
    my_person.val().name        // -> 'bob'
    my_person.val().email       // -> 'woot@woot.com'

  Example: a wrapper for something.
  Let's say we want a component that takes some other component but adds a delete link to it. You can do this by constructing a wrapper behavior. Here's how that looks:

  | delete_link_wrapper   = modus.wrapper('.item');     // Forwards .val() calls to the .item descendant
    delete_link_around(x) = delete_link_wrapper(jquery in div.deletable(a.remove('[nuke this thing]') /click(given.nothing in $(this).parent().remove()), div.item[x]));

  Now you can use this wrapper transparently with other components:

  | wrapped_person = delete_link_around(my_person);
    wrapped_person.val()        // -> my_person.val()
    wrapped_person.val(x)       // -> my_person.val(x)

  Example: a list of stuff.
  It's very common to want to display a list of things to the user. Modus makes this simple by giving you a list constructor that provides an array functor over the .val() function. All it
  needs is a constructor function for each element:

  | list_of_people_behavior = modus.list(person);
    list_of_people(ps)      = list_of_people_behavior(jquery in div).val(ps);

  At this point you can query the .val() method of a list of people and it will transparently map that into an array:

  | my_list = list_of_people([{name: 'foo', email: 'bar@bif.com'}, ...]);
    my_list.val()               // -> [{name: 'foo', email: 'bar@bif.com'}, ...]

Internal design concerns.
This section is mainly to help me iron out how modus interfaces with the world.

  Linkages.
  Modus objects refer to the jQuery objects they wrap, and the jQuery objects refer back to the modus objects. Modus objects also act as proxies for jQuery collections. For example:

  | var m = list_of_people([...]);
    m[0]                        // -> <table> DOM element (not jQuery-wrapped)
    m.length                    // -> 1
    m.jquery                    // -> jQuery containing a <table> element
    m.jquery.data('modus')      // -> something equivalent to m
    m.each(...)                 // equivalent to m.jquery.each(...) to make proxying work

  It's for this reason that you can use arbitrary jQuery selectors without modus having a hard reference ahead of time.

  Synchronization.
  A big aspect of modus is being able to synchronize a widget on-screen with server-side data. This can be done in one of two ways. If the component is self-contained and a diff-ish algorithm
  can determine what has changed, then we can update single components using some kind of replacement. (This assumes that the component's logical representation captures everything about its
  state.) Otherwise we can show the user any changes made on the server without trying to merge them. This has the advantage that the user won't have to worry about the merge.

Implementation.
Modus is implemented using caterwaul and assumes that the jQuery reference is available.

  caterwaul.js_all()(function (original_modus, $) {

  Global instance.
  This is a function that returns functions that create .data() references to themselves. The modus() function represents a generator for behaviors, and each behavior, when applied to a jQuery
  object, will set that object's .data('modus') to refer to itself. This allows later modus objects to refer to whatever behavior you've established for the element.

  If you invoke the modus() global on a jQuery object, that jQuery object's modus wrapper will be returned. If this doesn't exist, then the jQuery object will be returned instead.

    modus(x) = x && x instanceof jQuery ? x.data('modus') || x : calls_its_init_method() -se- add_initial_methods_to(it) -se- make_a_subclass_of_jquery(it),

      where [calls_its_init_method()      = bind [result = given.nothing in result.init.apply(result, arguments)] in result,
             make_a_subclass_of_jquery(f) = f -se [it.prototype = $(null), it.prototype.constructor = it],
             add_initial_methods_to(f)    = caterwaul.merge(f, modus.prototype)],

    modus.deglobalize() = modus -se [modus = original_modus],

    modus.prototype = {} -se [it.constructor     = modus,

                              it.init(jquery)    = jquery.data('modus', this) *![this[xi] = x] /seq
                                                   -then [this.length = jquery.length, this.jquery = jquery, caterwaul.merge(this, this.prototype)],

                              it.method(name, f) = this -se [this.prototype[name] = f],
                              it.each(f)         = this *![f.call(x, xi)] /seq],

  Metaprogramming methods.
  These are methods on behaviors that let you add methods in a systematic way. You can add additional meta-methods by extending modus.prototype.

    modus.prototype -se [

    Attr method.
    This adds a getter/setter attribute in jQuery style. If you pass arguments to the function then it acts as a setter returning the receiver, and if you pass no arguments then it acts as a
    retriever. For convenience these cases are pre-separated; you specify the getter and setter separately.

      it.attr(name, getter, setter) = this.method(name, given.x [arguments.length ? setter.apply(this, arguments) -re- this : getter.call(this)]),

    Selector method.
    This lets you create methods that dig through the DOM hierarchy to reference other modus nodes. You do this by specifying a hash that maps method names to selector strings. The object you
    get back from one of these methods will be a modus wrapper around the jQuery selector that matched. Ambiguous selectors are reduced to the first matching element.

      it.selector(mappings) = mappings /pairs *![this.method(name, selector_method_for(selector)) -where [name = x[0], selector = x[1]]] /seq -re- this
                              -where [selector_method_for(selector)() = modus(this.jquery.filter(selector).add(this.jquery.find(selector)).eq(0))]],

  Component combinators.
  These combine components somehow. The simplest is 'composite', which just generates a val() function that knows how to destructure single-layer hashes and convert .val() calls accordingly.
  It also gives you selector-accessors for the mappings.

    modus.composite(mappings) = modus().selector(mappings).attr('val', given.nothing [mappings /keys *[[x, this[x]().val()]]        |object |seq],
                                                                       given.hash    [hash     /keys *[[x, this[x]().val(hash[x])]] |object |seq -re- this]),

  The other combinator you get is 'list', which does exactly what you'd expect. Its parameter is a constructor function for each item; this will be called when you set the value of the list
  and should probably be called if you manually add elements. Note that the value constructor should return a modus object unless the logical value of each child is sufficiently described by
  jQuery's built-in val() function.

    modus.list(create_item) = modus().attr('val', given.nothing in this.children() *[modus($(x)).val()] /seq,
                                                  given.xs      in this.empty() -effect- xs *![it.append(create_item(x))] /seq -re- this);

    return modus})(typeof modus === 'undefined' ? undefined : modus, jQuery);
__
meta::template('comment', '\'\';     # A mechanism for line or block comments.');
meta::template('eval', <<'__');
my $result = eval $_[0];
terminal::warning("Error during template evaluation: $@") if $@;
$result;
__
meta::template('failing_conditional', <<'__');
my ($commands)    = @_;
my $should_return = $commands =~ / if (.*)$/ && ! eval $1;
terminal::warning("eval of template condition failed: $@") if $@;
$should_return;
__
meta::template('include', <<'__');
my ($commands) = @_;
return '' if template::failing_conditional($commands);
join "\n", map retrieve($_), split /\s+/, $commands;
__
meta::template('pinclude', <<'__');
# Just like the regular include, but makes sure to insert paragraph boundaries
# (this is required for SDoc to function properly).

my ($commands) = @_;
return '' if template::failing_conditional($commands);
my $text = join "\n\n", map retrieve($_), split /\s+/, $commands;
"\n\n$text\n\n";
__
internal::main();

__END__